<!DOCTYPE html>
<html lang="ru">
  <head>
    <title>Пазлы циклов (Loops) — Софт Эйт Софт</title>
    <meta charset="utf-8">
    <meta name="description" content="Блоки визуального программирования для создания циклов.">
    <base href="../../../">
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css">
  </head>
  <body><article>

    <h1>Пазлы циклов (Loops)</h1>

    <p>
      Эти пазлы предоставляют средства для создания циклов в ваших приложениях.
    </p>

    <img src="files/puzzles/puzzles-loops.jpg">

    <h2>Содержание</h2>

    [contents]


    [anchor:infinite_loops]

    <h2>Предупреждение о вечных циклах</h2>

    <p>
      Будьте осторожны с этими пазлами, так как легко создать вечные циклы и вызвать зависание вашего браузера. Если вы случайно сохранили такой ошибочный сценарий, вы можете восстановить предыдущую версию пазлов из <a href="manual/ru/introduction/Puzzles-Visual-Logic-Editor.html#Backup">резервного хранилища</a>.
    </p>


    [anchor:puzzles_reference]

    <h2>Перечень пазлов</h2>


    [anchor:repeat]

    <h3>repeat</h3>

    <p>
      Этот пазл запускает пазлы, помещенные в слот *do*, указанное количество раз.
    </p>

    <img src="files/puzzles/puzzles-loops-repeat.jpg">

    <p>
      Например, следующий набор пазлов создает несколько копий куба и размещает их случайным образом на сцене.
    </p>

    <img src="files/puzzles/puzzles-loops-repeat-example.jpg">


    [anchor:for_each]

    <h3>for each</h3>

    <p>
      Этот пазл выполняет итерацию по заданному списку и запускает пазлы, помещенные в слот *do* для каждого элемента этого списка. Элементы для соответствующей итерации доступны через автоматически создаваемую <a href='manual/ru/puzzles/Variables.html'>переменную</a>.
    </p>

    <img src="files/puzzles/puzzles-loops-for-each.jpg">

    <p>
      Например, следующий набор пазлов добавляет аннотации ко всем объектам из списка.
    </p>

    <img src="files/puzzles/puzzles-loops-for-each-example.jpg">


    [anchor:for_each_in_dict]

    <h3>for each in dict</h3>

    <p>
      Этот пазл выполняет итерацию по заданному словарю и запускает пазлы, помещённые в слот *do* для каждого поля словаря. Поля словаря представлены в виде автоматически создаваемых <a href='manual/ru/puzzles/Variables.html'>переменных</a> для ключа и значения.
    </p>

    <img src="files/puzzles/puzzles-loops-for-each-in-dict.webp">

    <p>
      Например, следующие пазлы выводят из словаря информацию о направлениях вылетов. Вывод осуществляется в браузерную консоль.
    </p>

    <img src="files/puzzles/puzzles-loops-for-each-in-dict-example.webp">


    [anchor:count_with]

    <h3>count with</h3>

    <p>
      Этот пазл похож на <a href='manual/ru/puzzles/Loops.html#for_each'>for each</a>, за исключением того, что в нем значения переменной цикла принимают значения из указанной числовой последовательности.
    </p>

    <img src="files/puzzles/puzzles-loops-count-with.jpg">

    <p>
      Например, следующий набор пазлов пробегает от `2` до `10` с шагом `2`, создавая таким образом числа `2`, `4`, `6`, `8` и `10`, клонирует куб на каждом шаге и использует эти числа для расположения копий вдоль оси X.
    </p>

    <img src="files/puzzles/puzzles-loops-count-with-example.jpg">


    [anchor:repeat_while_until]

    <h3>repeat while / until</h3>

    <p>
      Пазл *repeat while* запускает пазлы, помещенные в слот *do*, до тех пор, пока указанное логическое <a href='manual/ru/puzzles/Logic.html#comparison'>условие</a> истинно. Напротив, пазл *repeat until* прекращает выполнение сразу после того, как указанное логическое условие становится ложным.
    </p>

    <img src="files/puzzles/puzzles-loops-repeat-while-until.jpg">

    <p>
        Этот пазл хорошо подходит для ситуаций, когда внутри цикла что-то меняется, и это влияет на ваше решение продолжать или прекратить выполнение итераций. Например, следующий набор пазлов, использующий вариант *repeat while*, продолжает запрашивать ответ пользователя до тех пор, пока пользователь отвечает "да".
    </p>

    <img src="files/puzzles/puzzles-loops-repeat-while-example.jpg">

    <p>
      Вы можете использовать вариант *repeat until*, чтобы задать тот же вопрос, но в несколько более раздражающей манере, делая ответ "нет" единственной возможностью прекратить это.
    </p>

    <img src="files/puzzles/puzzles-loops-repeat-until-example.jpg">


    [anchor:break_continue]

    <h3>break / continue</h3>

    <p>
      Большинство циклов выполняется до тех пор, пока не будет выполнено условие завершения (в случае пазлов *repeat*) или пока все значения не будут приняты переменной цикла (в случае пазлов *count with* и *for each*). Этот пазл предоставляет дополнительные средства для управления поведением цикла. Хотя в приведенных ниже примерах используется пазл *for each*, они могут быть использованы с любым типом цикла.
    </p>

    <img src="files/puzzles/puzzles-loops-break-continue.jpg">

    <p>
      Вариант *break* обеспечивает ранний выход. Например, в следующем наборе пазлов выполняется поиск объекта с именем "Cube". Как только он найден и переменная result установлена, дальнейшая итерация не требуется, и поэтому мы выходим из цикла.
    </p>

    <img src="files/puzzles/puzzles-loops-break-example.jpg">

    <p>
      С другой стороны, вариант *continue* пропускает текущую итерацию, чтобы началась следующая итерация цикла. Например, следующий набор пазлов добавляет аннотации ко всем объектам на сцене, кроме "Cube".
    </p>

    <img src="files/puzzles/puzzles-loops-continue-example.jpg">


    <h2>Проблемы с пазлами?</h2>

    <p>Обращайтесь за помощью на наш <a href="https://www.soft8soft.com/ru/форумы/" target="_blank">форум</a>!</p>

  </article></body>
</html>
