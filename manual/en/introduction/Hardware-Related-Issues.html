<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Hardware-Related Issues - Soft8Soft</title>
    <meta charset="utf-8">
    <meta name="description" content="Learn how to deal with hardware-related problems and restrictions."/>
    <base href="../../../" />
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css" />
    <style>
        table, td, th {
          border: 1px solid #2194CE;
          border-collapse: collapse;
          padding: 10px;
          text-align: left;
          min-width: 180px;
          font-size: 16px;
        }
        table {
          margin-bottom: 20px;
        }
        th {
          text-align: center;
          text-decoration: none;
          color: #0b7188;
          font-size: 17px;
          font-family: 'Oswald', sans-serif;
          font-weight: normal;
        }
        td ul {
          margin: 10px 0px;
          padding-left: 20px;
        }
        td {
          vertical-align: top;
        }
        td.centered {
          text-align: center;
        }
      </style>
  </head>
  <body><article>

    <h1>Hardware-Related Issues</h1>

    <p>
        This manual section describes typical hardware and implementation-related
        issues that can happen during development of a WebGL application.
    </p>

    [contents]


    [anchor:too_many_attributes]

    <h2>Too Many Attributes</h2>

    <p>
        Once in a while when working on your scene you may face a problem where
        some objects are not rendered at all and the browser console shows the
        following error:
    </p>

    <figure style="max-width: 846px">
      <img src="files/hardware-related-issues/too-many-attributes.jpg" alt="Browser console">
      <figcaption>"Too many attributes" error in the browser console</figcaption>
    </figure>

    <p>
        This error means that some objects (apparently, the ones that couldn't
        be rendered) surpass the maximum amount of vertex attributes that can be
        used per shader.
    </p>

    <p>
        How many attributes an object uses depends on different factors:
        the presence and the number of shape keys (Blender) / morph targets
        (3ds Max) / blend shapes (Maya), the presence of skinning, certain
        material nodes, etc...
    </p>

    <p>
        Here's the table that explains how to calculate the number of attributes
        used:
    </p>

    <table>
        <thead>
            <tr>
                <th>Number of Attributes</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>3</td>
                <td>Mandatory attributes: <b>position</b>, <b>normal</b>, <b>uv</b>.</td>
            </tr>
            <tr>
                <td>+2x</td>
                <td>
                    Add for each shape key (Blender) / morph target (3ds Max) /
                    blend shape target (Maya). Maximum amount of attributes for
                    this category is capped to <b>+12</b>.
                </td>
            </tr>
            <tr>
                <td>+2</td>
                <td>Add if the object uses skinning.</td>
            </tr>
            <tr>
                <td>+1x</td>
                <td>
                    Add for each of the following nodes in the object's material
                    that use different<a href="manual/en/introduction/Hardware-Related-Issues.html#attribute-table0">*</a>
                    vertex colors:
                    <ul>
                        <li>Blender: <b>Attribute</b>, <b>Vertex Color</b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>+1x</td>
                <td>
                    Add for each of the following nodes in the object's material
                    that use different<a href="manual/en/introduction/Hardware-Related-Issues.html#attribute-table0">*</a>
                    uv maps except the first one (already covered by the mandatory
                    <b>uv</b> attribute, see the first row):
                    <ul>
                        <li>Blender: <b>UV Map</b></li>
                        <li>
                            3ds Max: <b>Bitmap</b> (only if "Mapping Type" set to "Texture"),
                            <b>Gradient Ramp</b>, <b>Noise</b> (only if "Mapping" set to "Explicit Map Channel")
                        </li>
                        <li>Maya: <b>place2dTexture</b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>+1</td>
                <td>
                    Add if the object's material has one of the following nodes:
                    <ul>
                        <li>Blender: <b>Normal Map</b>, <b>Tangent</b> (only in "UV Map" mode)</li>
                        <li>3ds Max: <b>Normal Bump</b></li>
                        <li>Maya: <b>aiNormalMap</b>, <b>bump2d</b> (only if the "Bump Interp" input > 0), <b>samplerInfo</b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>+1</td>
                <td>
                    Add if the object's material has one of the following nodes:
                    <ul>
                        <li>3ds Max: <b>Vertex Color</b></li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>

    <p id="attribute-table0" style="font-size: 14px;">
        *if several nodes use the same vertex color or a uv map then all those
        nodes count as a one node towards the limit.
    </p>

    <p>
        Generally, it's enough to stay in the limit of <b>16</b> vertex attributes
        (although some old / low-end devices can support only 8). Most often you
        should be concerned only about objects that use several shape keys.
        Other than that the amount of vertex attributes usually stays under the
        limit for a typical object/material.
    </p>


    [anchor:aa_issues]

    <h2>Aliasing Issues When Using Procedural Textures</h2>

    <p>Sometimes you might experience aliasing issues when using procedural textures. For example, when using Checker map:</p>

    <img src="files/hardware-related-issues/aa_msaa.jpg">

    <p>
      This happens when the *Anti-Aliasing* export setting is set to *MSAA* or *Auto* (which by default uses MSAA 4x on any compatible hardware). MSAA (multisample anti-aliasing) technique produces decent image quality and has low performance impact, however it does not work well for procedural textures with abrupt changes of object color.
    </p>

    <p>Switching *Anti-Aliasing* technique to *FXAA* fixes the issue:</p>

    <img src="files/hardware-related-issues/aa_fxaa.jpg">

    <p>*FXAA* uses post-processing rendering to reduce aliasing and works good for such "edges" generated by procedural maps.</p>


    [anchor:z_fighting]

    <h2>Intersection Artifacts When Two Objects are Located Close to Each Other</h2>

    <p>
      Sometimes you might experience artifacts similar to these:
    </p>

    <img src="files/hardware-related-issues/z-fighting.jpg" alt="z-fighting artifacts">

    <p>
      This is called *z-fighting* (<a href="https://en.wikipedia.org/wiki/Z-fighting" target="_blank">technical stuff on Wikipedia</a>) and happens when different polygons have equal distances to the camera, or their distances differ very slightly.
    </p>

    <p>
      To fix it you need to do one of the following:
    </p>

    <ul>
      <li>The most straightforward fix — place your objects further from each other.</li>
      <li>Increase <em>near</em> (or <em>clip start</em>) camera distance and/or decrease <em>far</em> (or <em>clip end</em>) camera distance. This will make camera distance range smaller and thus improve precision of the values stored in the depth buffer.</li>
      <li>If you need to place a billboard texture above some surface — disable *Depth Test* on the billboard material and increase *Rendering Order* parameter on the billboard object. The billboard will be rendered after the surface object and will ignore depth stored by that object. This effectively eliminates any z-fighting which might happen between the two objects.</li>
    </ul>


  </article></body>
</html>
