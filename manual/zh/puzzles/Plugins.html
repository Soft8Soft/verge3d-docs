<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>拼图插件参考 - Soft8Soft</title>
    <meta charset="utf-8">
    <meta name="description" content="Verge3D拼图编辑器的自定义插件系统。"/>
    <base href="../../../" />
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css" />
  </head>
  <body><article>

    <h1>插件 | Plugins</h1>

    <p><a href="manual/zh/introduction/Puzzles-Visual-Logic-Editor.html">Verge3D拼图编辑器</a>提供了加载您自己自定义拼图的能力，从而使您可以用您一直想要的功能来扩展编辑器的功能。</p>


    <h2>内容</h2>

    [contents] [anchor:installing]

    <h2>安装插件</h2>

    <p>插件是包含一堆与插件相关的文件的目录。插件应该放在Verge3D的*puzzles/plugins*文件夹中，以便被拼图编辑器识别。仅此而已！重新加载编辑器页面后，所有已安装的插件就会出现在编辑器工具箱的底部，紧随所有标准拼图类目之后。</p><img src="files/puzzles/puzzles-plugins-ui-location.jpg" class="centered" style="max-width: 570px"> <span class="img-caption">工具箱中的插件类目</span><p id="example_plugin" class="note"><u>提供给插件开发者：</u><br/> 这里有一个实用的参考插件实例，包含了一些典型的拼图模块：<a href="files/puzzles/ExamplePlugin.zip">ExamplePlugin.zip</a>。您可以将其解压到 *puzzles/plugins* 文件夹中，然后在工具箱中查看 &quot;Example Plugin &quot;的拼图类目。</p>

    [anchor:plugin_files_overview]

    <h2>插件文件概述</h2>一个典型的插件是一个包含*init.plug*文件的目录，其中包含了插件的通用设置，还有一堆 <b>*.block</b> 文件，每个文件都定义一个拼图模块。如果您使用的文本编辑器支持语法高亮，那么请在开启这两种文件格式时使用HTML模式。[anchor:init_plug_file_format]

    <h3>init.plug文件格式</h3>

    <p>*init.plug*是一个强制性的插件文件，它用于指定常规的插件设置。在该文件中，您可以定义工具箱的条目是什么样子的。您也可以在那里为拼图添加一些初步的javascript代码。下面这个简单的示例列出了您将在*init.plug*文件中看到的内容：</p>
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;label text=&quot;My Awesome Plugin v1.0&quot;&gt;&lt;/label&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;/block&gt;&lt;block type=&quot;doSomethingCool&quot;&gt;&lt;/block&gt;&lt;/category&gt;&lt;script&gt; function code() { return `console.log(&apos;Powered by My Awesome Plugin!&apos;);`; } &lt;/script&gt;
</code>
 [anchor:init_plug_category]

    <h4>Category(类目)</h4>

    <p>*category*部分是一个XML树，它定义了插件及其拼图模块在拼图编辑器工具箱中的显示方式。虽然它是可选的，但如果*init.plug*文件中没有*category*，那么此插件不会被加载到拼图编辑器中。 <br/><br/> 您可以通过*category*设置以下几个选项：</p>

    [anchor:init_plug_toolbox_entry_name]

    <h5>工具箱中的条目名称</h5>

    <p class="indented">通过*name*属性指定。 
<code>
&lt;category name=&quot;My Awesome Plugin&quot;&gt;&lt;/category&gt;
</code>
</p>

    [anchor:init_plug_toolbox_entry_color]

    <h5>工具箱中的条目颜色</h5>

    <p class="indented">通过*color*属性指定。
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;/category&gt;
</code>
 可以用以下格式来定义颜色：</p>

    <ul id="color_formats">
        <li>十六进制三联体，如： <b>#f61</b> 或 <b>#f0562f</b></li>
        <li>在0°-360°范围内的色相值，例如： <b>140</b> （在HSV颜色模型的范围内，S和V分别固定为45%和65%）.</li>
        <li>颜色关键词，如： <b>aqua</b>, <b>black</b>, <b>blue</b>, <b>fuchsia</b>, <b>gray</b>, <b>green</b>, <b>lime</b>, <b>maroon</b>, <b>navy</b>, <b>olive</b>, <b>purple</b>, <b>red</b>, <b>silver</b>, <b>teal</b>, <b>white</b> 和 <b>yellow</b></li>
    </ul>

    [anchor:init_plug_available_puzzles]

    <h5>可用的拼图</h5>

    <div class="indented">
        <p>要使一个拼图模块在插件的工具箱类目中可用，应该通过*block*元素和其*type*属性来指定。*type*属性可以参考以下拼图。</p>

        <ul>
            <li id="available_puzzles_plugin">由插件自己定义的拼图&mdash;&mdash;在这种情况下，*type*应该根据您的插件目录中相应的.block文件的名称来设置（例如，*myPuzzle*表示block文件*my_awesome_plugin/myPuzzle.block*) 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;/block&gt;&lt;/category&gt;
</code>
</li>
            <li id="available_puzzles_stock">库存拼图模块 - *type*应该等于库存拼图的类型（例如：*math_number*）。这样就可以直接在您的插件的工具箱类目中添加库存拼图。 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;math_number&quot;&gt;&lt;/block&gt;&lt;/category&gt;
</code>
</li>
            <li>由其他插件定义的拼图&mdash;&mdash;*type*应该是*PLUGIN_DIRECTORY_NAME/PUZZLE_TYPE*的形式。例如，标准的 <a href="manual/zh/puzzles/ECommerce.html">电子商务</a> 插件的拼图可以这样引用： 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;E-Commerce/placeOrder&quot;&gt;&lt;/block&gt;&lt;/category&gt;
</code>
</li>
        </ul>

        <p id="puzzle-xml-tree">为查找出某个拼图模块的类型，您可以使用拼图上下文菜单中的 &quot;Print Puzzle XML Tree(打印拼图XML树)&rdquo; 选项：</p><img src="files/puzzles/puzzles-plugins-print-puzzle-xml-tree.png" class="width-clear border-gray"><p>该菜单选项可将拼图的XML树打印到浏览器控制台。您可以在其中找到拼图类型以及整个XML结构，可用于在设置 <a href="manual/zh/puzzles/Plugins.html#init_plug_default_input_field_values">默认的输入和字段值</a> 时参考。</p><img src="files/puzzles/puzzles-plugins-puzzle-xml-tree.png" class="width-clear border-gray"><p>&quot;Print Puzzle XML Tree(打印拼图XML树)&quot; 菜单选项提供了一个简单的方法，可以一次性将一整组拼图模块添加到您的插件中。这样便于您创建某种由相连的拼图模块组成的&rdquo;代码片段(snippets)&rdquo;并将其放入插件中。这使得它有点类似于 <a href="manual/zh/puzzles/Library.html">拼图库</a> 。<p>下面的示例解释了如何执行这一操作：</p>
            <ul>
                <li>在拼图编辑器中创建一些拼图模块：<br/> <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree-step-1.png" class="width-clear border-gray"></li>
                <li>用鼠标右键点击最上面或最外部的模块，选择 &quot;Print Puzzle XML Tree(打印拼图XML树)&quot; ：<br/> <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree-step-2.png" class="width-clear border-gray"></li>
                <li>进入浏览器控制台，复制打印出来的内容（下面是在谷歌Chrome浏览器中的截图）：<br/> <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree-step-3.png" class="width-clear border-gray"></li>
                <li>把它粘贴到*init.plug*文件中的 <b>&lt;category&gt;</b> 元素内，并保存该文件：<br/> <img src="files/puzzles/puzzles-plugins-puzzle-xml-tree-step-4.png" class="width-clear border-gray"></li>
                <li>然后重新加载拼图编辑器，您所复制的模块就会出现在插件的类目中。</li>
            </ul>
        </p>
    </div>

    [anchor:init_plug_puzzles_order]

    <h5>拼图顺序</h5>

    <p class="indented">拼图模块按照您在*init.plug*文件中定义的顺序在工具箱中排列。 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;/block&gt;&lt;block type=&quot;doSomethingCool&quot;&gt;&lt;/block&gt;&lt;!-- &lt;block type=&quot;testPuzzle&quot;&gt;&lt;/block&gt; --&gt;&lt;block type=&quot;anotherPuzzle&quot;&gt;&lt;/block&gt;&lt;/category&gt;
</code>
 <img src="files/puzzles/puzzles-plugins-block-order.jpg" style="max-width: 523px"></br> 注意，被注释掉的拼图模块 &quot;testPuzzle &quot;并没有显示在工具箱中。</p>

    [anchor:init_plug_text_labels]

    <h5>文本标签</h5>

    <div class="indented">
        <p>您可以通过*label*元素将文本标签添加到工具箱类目中：</p>
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;label text=&quot;My Awesome Plugin v1.0&quot;&gt;&lt;/label&gt;&lt;label text=&quot;Main Puzzles:&quot;&gt;&lt;/label&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;/block&gt;&lt;block type=&quot;doSomethingCool&quot;&gt;&lt;/block&gt;&lt;label text=&quot;Other:&quot;&gt;&lt;/label&gt;&lt;block type=&quot;anotherPuzzle&quot;&gt;&lt;/block&gt;&lt;/category&gt;
</code>
 <img src="files/puzzles/puzzles-plugins-label-elements.jpg" style="max-width: 523px"></br><p class="note">*label*元素不适合显示多行文本，即不会换行。</p>

        <p>*label*元素也可以在一定程度上定义样式。它们支持*web-class*属性，可用于为*label*元素分配自定义的CSS类。该类的CSS规则可以在*init.plug*的*script*部分定义。下方示例描述了实现方式：</p>
<code>
&lt;category name=&quot;Example Plugin&quot; color=&quot;#a52a2a&quot;&gt;&lt;label text=&quot;Example Plugin v1.0 by Soft8Soft&quot; web-class=&quot;example-plugin__label&quot;&gt;&lt;/label&gt;&lt;/category&gt;&lt;script&gt; const styleElem = document.createElement(&apos;style&apos;); styleElem.innerHTML = ` .example-plugin__label .blocklyFlyoutLabelText { fill: #a52a2a; font-style: italic; font-weight: bold; text-decoration: underline; } `; document.head.appendChild(styleElem); &lt;/script&gt;
</code>
<p>这是应用自定义CSS规则后的样子：</p><img src="files/puzzles/puzzles-plugins-label-elements-styled.png" class="width-clear"><p class="note">在为*web-class*属性规划CSS类名时，建议考虑限定CSS范围。例如使用拼图插件名作为专有前缀：在上面的例子中使用了 &quot;example-plugin__label &quot;类的 &quot;example-plugin &quot;部分作为前缀。这样，意外破坏页面中已经使用的CSS类的可能性就很小了。</p>
    </div>

    [anchor:init_plug_separator_elements]

    <h5>分隔符</h5>

    <p class="indented">分隔符可以用来改变拼图模块之间的距离。您可以通过*sep*元素在工具箱类目中添加分隔符。*gap*属性指定了间隙的宽度，单位为像素。不使用*sep*时，模块之间的默认距离等于24像素。 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;/block&gt;&lt;sep gap=&quot;0&quot;&gt;&lt;/sep&gt;&lt;block type=&quot;doSomethingCool&quot;&gt;&lt;/block&gt;&lt;sep gap=&quot;80&quot;&gt;&lt;/sep&gt;&lt;block type=&quot;anotherPuzzle&quot;&gt;&lt;/block&gt;&lt;/category&gt;
</code>
 <img src="files/puzzles/puzzles-plugins-sep-elements.jpg" style="max-width: 523px"></br></p>

    [anchor:init_plug_available_puzzles_init]

    <h5>在 &quot;init&rdquo; 初始化标签中可用的拼图模块</h5>

    <p class="indented">默认情况下，拼图模块只在*main*和用户创建的选项卡中可用，在*init(初始化)*选项卡中不可用。这是因为*init*选项卡所产生的代码是在Verge3D应用被加载与完全初始化之前执行的。这意味着那些预期用于3D场景、3D对象、材质的拼图并不适合在*init*中使用，如果使用会导致应用崩溃。但是，对于不作用于3D场景的拼图应该不会有这样的问题。例如，可以在*init*中使用预加载资源拼图或设置用户界面的拼图。<br/><br/>如果需要让拼图模块出现在*init*标签的工具箱中，您需要在拼图的*block*元素中设置*allow-init*属性为*true*（这也适用于*label*和*sep*元素）。 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;label text=&quot;My Awesome Plugin v1.0&quot; allow-init=&quot;true&quot;&gt;&lt;/label&gt;&lt;label text=&quot;Main Puzzles:&quot;&gt;&lt;/label&gt;&lt;block type=&quot;myPuzzle&quot; allow-init=&quot;true&quot;&gt;&lt;/block&gt;&lt;block type=&quot;doSomethingCool&quot;&gt;&lt;/block&gt;&lt;label text=&quot;Other:&quot;&gt;&lt;/label&gt;&lt;block type=&quot;anotherPuzzle&quot;&gt;&lt;/block&gt;&lt;/category&gt;
</code>
 <img src="files/puzzles/puzzles-plugins-allow-init.jpg" style="max-width: 523px"></br> 注意，没有*allow-init*的*block*和*label*元素是不会显示在工具箱中的。</p>

    [anchor:init_plug_default_input_field_values]

    <h5>默认的输入和字段值</h5>

    <p class="indented">如果一个拼图模块有模块输入和/或字段输入，那么您可以指定它们的占位模块和/或默认值。模块输入即连接其他拼图模块的插槽，字段输入即不以拼图模块为形态的UI元素，如选择器、复选框、文本字段等.这个功能有两个目的：为用户提供提示，告诉他们可以插入哪些类型的模块到输入插槽中，同时也可快速调用拼图模块。<br/><br/>比方说，您的拼图模块有一个名为 &quot;myNumber &quot;的输入。这里您可以添加一个*math_number*类型的占位符模块插入该槽。
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;value name=&quot;myNumber&quot;&gt;&lt;block type=&quot;math_number&quot;&gt;&lt;/block&gt;&lt;/value&gt;&lt;/block&gt;&lt;/category&gt;
</code>
 其外观如下：<br/> <img src="files/puzzles/puzzles-plugins-default-value-input.jpg" style="max-width: 523px"><br/><br/> 插入输入插槽的占位符模块也可以是一个*shadow(影子)*模块。*shadow*模块与普通模块基本相同，但它们可被您插入到相应输入插槽中的模块自动替换，当您从插槽中移除该模块时，它们又会自动出现。这使得*shadow*模块比普通的占位符模块更容易使用。<br/><br/>*shadow*模块的定义方式与普通占位符模块几乎相同，唯一的区别是*block*元素被类似的*shadow*元素所取代。
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;value name=&quot;myNumber&quot;&gt;&lt;shadow type=&quot;math_number&quot;&gt;&lt;/shadow&gt;&lt;/value&gt;&lt;/block&gt;&lt;/category&gt;
</code>
 它看起来会是这样的：<br/> <img src="files/puzzles/puzzles-plugins-default-value-input-shadow.jpg" style="max-width: 523px"><br/><br/> 拼图模块可以有语句输入，这些输入通常包裹着一系列的子拼图模块。比方说，您的拼图模块有一个名为 &quot;myStatement&quot; 的语句输入，那么您可以在这个输入中添加几个占位符模块，如下所示：
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;statement name=&quot;myStatement&quot;&gt;&lt;block type=&quot;addHTMLElement&quot;&gt;&lt;next&gt;&lt;block type=&quot;setHTMLElemAttribute&quot;&gt;&lt;/block&gt;&lt;/next&gt;&lt;/block&gt;&lt;/statement&gt;&lt;/block&gt;&lt;/category&gt;
</code>
 这里使用的*statement*元素通过*name*属性引用 &quot;myStatement&rdquo; 输入，并在输入中添加了一些占位符模块。另外，这里还使用了*next*元素，用于链接一系列的占位符模块。这个设置的结果如下所示：<br/> <img src="files/puzzles/puzzles-plugins-default-value-statement.jpg" style="max-width: 735px"><br/><br/> 如果您的拼图模块有一个名为 &quot;myCheckbox&quot; 的复选框字段，那么您可以像这样定义它的默认状态（*true* - 启用，*false* - 禁用）：
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;field name=&quot;myCheckbox&quot;&gt;true&lt;/field&gt;&lt;/block&gt;&lt;/category&gt;
</code>
 结果如下：<br/> <img src="files/puzzles/puzzles-plugins-default-dummy-input.jpg" style="max-width: 523px"><br/><br/> <span id="default_input_values_compound"></span> 通过使用占位符模块和默认字段值，您可以定义复杂的复合拼图，类似于可以添加到 <a href="manual/zh/puzzles/Library.html#using_entries">拼图库</a>中的内容： <img src="files/puzzles/puzzles-plugins-compound-puzzle.jpg" style="max-width: 600px"><br/>上图中复杂拼图设置的*init.plug*的代码示例如下： 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;statement name=&quot;STATEMENT_0&quot;&gt;&lt;block type=&quot;whenClicked&quot;&gt;&lt;value name=&quot;VALUE&quot;&gt;&lt;block type=&quot;objectList&quot;&gt;&lt;field name=&quot;FIELDNAME&quot;&gt;Cube&lt;/field&gt;&lt;/block&gt;&lt;/value&gt;&lt;/block&gt;&lt;/statement&gt;&lt;statement name=&quot;STATEMENT_1&quot;&gt;&lt;block type=&quot;loadScene&quot;&gt;&lt;value name=&quot;URL&quot;&gt;&lt;block type=&quot;text&quot;&gt;&lt;field name=&quot;TEXT&quot;&gt;my_scene.gltf&lt;/field&gt;&lt;/block&gt;&lt;/value&gt;&lt;/block&gt;&lt;/statement&gt;&lt;statement name=&quot;STATEMENT_2&quot;&gt;&lt;block type=&quot;show&quot;&gt;&lt;value name=&quot;VALUE&quot;&gt;&lt;block type=&quot;objectList&quot;&gt;&lt;field name=&quot;FIELDNAME&quot;&gt;something&lt;/field&gt;&lt;/block&gt;&lt;/value&gt;&lt;/block&gt;&lt;/statement&gt;&lt;/block&gt;&lt;/category&gt;
</code>
<div class="indented">
            <p class="note">查看 <a href="manual/zh/puzzles/Plugins.html#puzzle-xml-tree">&quot;Print Puzzle XML Tree(打印拼图XML树)&rdquo;</a> 上下文菜单选项。它有助于您找出感兴趣的拼图模块的XML结构（输入和字段的配置）。</p>
        </div>
    </p>

    [anchor:init_plug_toolbox_subcategories]

    <h5>工具箱内的子类目</h5>

    <p class="indented">在编辑器的工具箱中，一个类目可以有子类目，而子类目也可以有子类目，以此类推...如果您想把插件拼图组织成一个树状结构，可以使用此功能。<br/><br/>通过嵌套*category*元素来实现： 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;/block&gt;&lt;category name=&quot;1&quot; color=&quot;red&quot;&gt;&lt;category name=&quot;1.1&quot; color=&quot;silver&quot;&gt;&lt;block type=&quot;anotherPuzzle&quot;&gt;&lt;/block&gt;&lt;/category&gt;&lt;/category&gt;&lt;category name=&quot;2&quot; color=&quot;blue&quot;&gt;&lt;block type=&quot;doSomethingCool&quot;&gt;&lt;/block&gt;&lt;/category&gt;&lt;/category&gt;
</code>
 <img src="files/puzzles/puzzles-plugins-subcategories.jpg" style="max-width: 523px"><br/> 任何*category*都可以同时包含*category*和*block*元素（但这不是强制性的）。这样在一个父级类目中可同时包含拼图模块和子类目。</p>

    [anchor:init_plug_script]

    <h4>脚本</h4>

    <p><b>&lt;script&gt;</b> 元素是*init.plug*的一个可选的部分。它可以用来为拼图模块添加一些初始化代码。有时候，在您的拼图被使用之前，您可能需要进行繁重的计算和缓存一些数据&mdash;&mdash;这就是 <b>&lt;script&gt;</b> 的作用。</p>

    <p>如果您在 <b>&lt;script&gt;</b> 中定义了一个*code()*函数，它将被用来生成代码，并在所有拼图之前执行一次。这个*code()*函数会返回一个包含javascript代码的字符串。 
<code>
&lt;script&gt; function code() { // this line will be executed before any puzzles return `console.log(&apos;Powered by My Awesome Plugin!&apos;);`; } &lt;/script&gt;
</code>
</p>

    <p class="note">由*code()*函数返回的初始化代码只有在该插件的拼图在应用中被实际使用时，才会被添加到生成的逻辑文件中（被添加到工作区且未被禁用）。</p>

    [anchor:block_file_format]

    <h3>.block文件格式</h3>

    <p>以 <b>.block</b> 为扩展名的插件文件是用来定义单个拼图模块的，特别是定义一个拼图模块的外观以及它在添加到工作区时应该产生的代码。一个插件可以没有 <b>.block</b> 文件。如果您想创建一个只有 <a href="manual/zh/puzzles/Plugins.html#available_puzzles_stock">库存</a> 拼图模块的工具箱类目（可以包含 <a href="manual/zh/puzzles/Plugins.html#default_input_values_compound">更复杂的模块设置</a>），可使用此方法。<br/><br/>一个 <b>.block</b> 文件的名称被用来指示哪些拼图模块应该被 <a href="manual/zh/puzzles/Plugins.html#available_puzzles_plugin">包含在插件的工具箱类目</a> 中。</p>

    <p>下面是一个 <b>.block</b> 文件的最小化实例。 
<code>
&lt;template color=&quot;green&quot;&gt;&lt;dummy&gt;&lt;label&gt;myPuzzle&lt;/label&gt;&lt;/dummy&gt;&lt;/template&gt;&lt;script&gt; function code(block) { return `console.log(&apos;This is my first puzzle!&apos;);`; } &lt;/script&gt;
</code>
 这里我们有一个 <b>&lt;template&gt;</b> 元素，定义了拼图模块的外观。还有一个 <b>&lt;script&gt;</b> 元素，里面有一个 *code()* 函数。这个 *code()* 函数返回一个字符串，其中包含将生成的代码，以代替这个拼图。<br/><br/>因此，根据上面的实例，我们期望得到的简单拼图模块是绿色的，并且有一个  &quot;myPuzzle&quot; 文本标签。<br/> <img src="files/puzzles/puzzles-plugins-block-minimal-appearance.jpg" style="max-width: 523px"><br/><br/> 如果将其添加到工作区，它将会在浏览器控制台中打印出以下信息：<br/> <img src="files/puzzles/puzzles-plugins-block-minimal-console.jpg" style="max-width: 523px"><br/></p>

    [anchor:block_file_template]

    <h4>Block模板</h4>

    <p>拼图模块的外观可以通过两种方式定义：通过 <b>&lt;template&gt;</b> XML元素和通过 *template()* 函数。前者更简单易用。例如，一个典型拼图的 <b>&lt;template&gt;</b> 可以是这样的：</p>
<code>
&lt;template color=&quot;green&quot; inline=&quot;true&quot; output=&quot;Dictionary&quot; tooltip=&quot;This is my first puzzle!&quot; help=&quot;https://soft8soft.com&quot; &gt;&lt;dummy name=&quot;myDummyInput&quot;&gt;&lt;label&gt;enable&lt;/label&gt;&lt;checkbox name=&quot;myCheckbox&quot;&gt;true&lt;/checkbox&gt;&lt;/dummy&gt;&lt;value name=&quot;myValueInput&quot;&gt;&lt;label&gt;input value&lt;/label&gt;&lt;/value&gt;&lt;/template&gt;&lt;script&gt; function code(block) { return `console.log(&apos;This is my first puzzle!&apos;);`; } &lt;/script&gt;
</code>
<p>另一种方法是使用 *template()* 函数。这是一个您可以在 <b>&lt;script&gt;</b> 元素内定义的函数。它也可以用来配置拼图的外观，但这次是通过 <a href="https://developers.google.com/blockly/reference/overview">Blockly JavaScript API</a> 而非XML元素与属性配置的。它会接收 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg">Blockly.BlockSvg</a> 实例型的*block*参数。<br/><br/>可以通过使用 *template()* 函数来重写上面实例中的模块，如下所示：</p>
<code>
&lt;script&gt; function template(block) { block.setColor(&apos;green&apos;); block.setInputsInline(true); block.setOutput(true, &apos;Dictionary&apos;); block.setTooltip(&apos;This is a test puzzle!&apos;); block.setHelpUrl(&apos;https://soft8soft.com&apos;); block.appendDummyInput(&apos;myDummyInput&apos;) .appendField(&apos;enable&apos;) .appendField(new Blockly.FieldCheckbox(true), &apos;myCheckbox&apos;); block.appendValueInput(&apos;myValueInput&apos;) .appendField(&apos;input value&apos;); } function code(block) { return `console.log(&apos;This is my first puzzle!&apos;);`; } &lt;/script&gt;
</code>
<p>这种方法更加灵活，但需要对相应的API有所了解。如果您需要做一些无法通过 <b>&lt;template&gt;</b> 元素实现的设置，可使用这种方法。此外，您可以同时使用 <b>&lt;template&gt;</b> 和 *template()* 。</p>

    <p class="note">本节提供了 <b>&lt;template&gt;</b> （*XML*）和 *template()*(*JS*)两种变体的示例。</p>

    <p class="note">请注意，本节只是简要介绍了如何创建一个自定义拼图模块。关于进行常规定制的详细介绍，请查看谷歌Blockly关于 <a href="https://developers.google.com/blockly/guides/create-custom-blocks/overview">自定义模块</a> 和 <a href="https://developers.google.com/blockly/guides/create-custom-blocks/fields/overview">字段</a> 的文档。</p>

    [anchor:block_file_template_block_color]

    <h5>Block的颜色</h5>

    <div class="indented">

        <p>您可以设置拼图模块的颜色，使其外观更加独特。</p><img src="files/puzzles/puzzles-plugins-template-color.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>可以通过 *color* 属性来设置。 
<code>
&lt;template color=&quot;green&quot;&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setColour">block.setColor</a> 来设置。 
<code>
&lt;script&gt; function template(block) { block.setColor(&apos;green&apos;); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>

        <p>颜色必须是这里描述的格式之一： <a href="manual/zh/puzzles/Plugins.html#color_formats">颜色格式</a>。</p>
    </div>

    [anchor:block_file_template_block_tooltip]

    <h5>Block的工具提示</h5>

    <div class="indented">
        <p>您可以添加一个工具提示，当把鼠标悬停在一个模块上面时就会出现。工具提示用于向用户提供简单的描述，如拼图的用途，作用方式的，有哪些使用提示等等。</p><img src="files/puzzles/puzzles-plugins-template-tooltip.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>可以通过 *tooltip* 属性来设置。 
<code>
&lt;template tooltip=&quot;This is my first puzzle!&quot;&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setTooltip">block.setTooltip</a> 来设置。 
<code>
&lt;script&gt; function template(block) { block.setTooltip(&apos;This is my first puzzle!&apos;); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>
    </div>

    [anchor:block_file_template_block_help_url]

    <h5>Block的帮助URL</h5>

    <div class="indented">

        <p>如果 <a href="manual/zh/puzzles/Plugins.html#block_file_template_block_tooltip">工具提示</a> 不足以记录拼图描述，您也可以为其添加一个链接，指向一个有更详尽文档说明的网页。此链接将被用于拼图上下文菜单中的*帮助*条目（在拼图上点击右键）：</p><img src="files/puzzles/puzzles-plugins-template-helpurl.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>可以通过 *help* 属性设置。 
<code>
&lt;template help=&quot;https://www.soft8soft.com/&quot;&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setHelpUrl">block.setHelpUrl</a> 来设置。 
<code>
&lt;script&gt; function template(block) { block.setHelpUrl(&apos;https://www.soft8soft.com/&apos;); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>
    </div>

    [anchor:block_file_template_block_adding_inputs]

    <h5>添加输入插槽</h5>

    <div class="indented">
        <p>拼图模块可以包含输入插槽来插入其他模块。它们也可以使用非模块的UI元素，如复选框或文本字段。有3种不同类型的输入：*value input*，*statement inputs*和*dummy inputs*。<ul>
                <li id="adding_inputs_value">*value input* - 可用于插入具有返回值（输出连接）模块的输入插槽，例如，带有一些数学模块的输入&mdash;&mdash;数学模块会计算并返回数值，可由父模块（包含输入插槽的模块）访问。</li>
                <li id="adding_inputs_statement">*statement input* - 可用于插入一组代表一系列连续动作的模块的输入，例如 <a href="manual/zh/puzzles/Logic.html#if_else">if-else</a> 拼图就有这种类型的输入，用于在 &quot;if &quot;或 &quot;else &quot;条件下将拼图模块分组。</li>
                <li id="adding_inputs_dummy">*dummy inputs* - 此类输入插槽只适用于添加非模块式的用户界面元素，如复选框、文本字段、图片等。更多信息见 <a href="manual/zh/puzzles/Plugins.html#block_file_template_adding_fields">添加字段</a> 。</li>
            </ul>
        </p>

        <p>您可以在下图中看到这些类型的输入的区别。</p><img src="files/puzzles/puzzles-plugins-template-input-types.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>使用 <b>&lt;value&gt;</b> ， <b>&lt;statement&gt;</b> 和 <b>&lt;dummy&gt;</b> 等元素来添加输入。*value* 和 *statement* 输入必须有一个名称（使用它们的 *name* 属性）。*dummy* 输入通常不需要名字，它们只是 <a href="manual/zh/puzzles/Plugins.html#block_file_template_adding_fields">字段</a> 的容器。 
<code>
&lt;template&gt;&lt;value name=&quot;myInput&quot;&gt;&lt;/value&gt;&lt;statement name=&quot;myStatement&quot;&gt;&lt;/statement&gt;&lt;dummy&gt;&lt;checkbox name=&quot;myCheckbox&quot;&gt;true&lt;/checkbox&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>使用 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#appendValueInput">block.appendValueInput</a> , <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#appendStatementInput">block.appendStatementInput</a> 和 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#appendDummyInput">block.appendDummyInput</a> 方法来添加输入。*value* 和 *statement* 输入必须（通过*name*属性）被命名。*dummy* 输入通常不需要名字，它们只是 <a href="manual/zh/puzzles/Plugins.html#block_file_template_adding_fields">字段</a> 的容器。 
<code>
&lt;script&gt; function template(block) { block.appendValueInput(&apos;myValue&apos;); block.appendStatementInput(&apos;myStatement&apos;); block.appendDummyInput() .appendField(new Blockly.FieldCheckbox(true), &apos;myCheckbox&apos;); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>
    </div>

    [anchor:block_file_template_arrangement_inputs]

    <h5>输入的排列</h5>

    <div class="indented">
        <p>模块状输入可以垂直（默认）或水平排列。</p><img src="files/puzzles/puzzles-plugins-inputs-inline.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>可以通过 *inline* 设置为 *true* 或 *false* 的属性。为 *false* 时使用垂直排列，为 *true* 时使用水平排列的变体。 
<code>
&lt;template inline=&quot;true&quot;&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setInputsInline">block.setInputsInline</a> 方法设置。该方法可接收一个为 *true* 或 *false* 的参数。为 *false* 时使用垂直排列，为 *true* 时使用水平排列的变体。 
<code>
&lt;script&gt; function template(block) { block.setInputsInline(true); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>
    </div>

    [anchor:block_file_template_adding_fields]

    <h5>添加字段</h5>

    <div class="indented">
        <p>您可以在拼图中添加诸如文本标签、复选框、下拉列表、文本输入等UI元素。这些UI元素被称为 &quot;fields(字段)&quot;。它们可被添加到任何类型的输入中，但如果您不想为拼图模块额外创建输入插槽，可一致使用 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy input</a> 输入。</p>

        <p>所有字段都有几个共同点：<ul>
                <li>可以指定一个可选的 *name* 参数，这通常用于在 <a href="manual/zh/puzzles/Plugins.html#block_file_code">code()</a> 函数中引用该字段，以获得该字段的值。</li>
                <li>能够提供一个可选的默认值。如前所述，在*init.plug*的 <a href="manual/zh/puzzles/Plugins.html#init_plug_default_input_field_values">类目</a> 中指定的默认值始终比在拼图模板中定义的默认值具有更高的优先级。</li>
            </ul>
        </p>

        <p>让我们来看看如何在拼图中添加各种字段。</p>
    </div>

    <ul>
        <li>
            <p>label - 一个不可编辑的文本字段</p><img src="files/puzzles/puzzles-plugins-field-text-label.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>可以通过 <b>&lt;label&gt;</b> 元素嵌套在 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> 、 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入中添加。 
<code>
&lt;template&gt;&lt;dummy&gt;&lt;label&gt;a text label&lt;/label&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

                <label>JS</label>
                <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a> 方法和 <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldLabel">Blockly.FieldLabel</a> 添加到 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> ， <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入。 
<code>
&lt;script&gt; function template(block) { block.appendDummyInput() .appendField(new Blockly.FieldLabel(&apos;a text label&apos;)); } &lt;/script&gt;
</code>
</div>
            </v3d-tabs>
        </li>

        <li>
            <p>text - 一个可编辑的文本字段</p><img src="files/puzzles/puzzles-plugins-field-text.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>可以通过 <b>&lt;text&gt;</b> 元素嵌套在 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> ， <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入中添加。 
<code>
&lt;template&gt;&lt;dummy&gt;&lt;text name=&quot;myText&quot;&gt;default text&lt;/text&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

                <label>JS</label>
                <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a> 方法和 <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldTextInput">Blockly.FieldTextInput</a> 添加到 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> ， <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入。 
<code>
&lt;script&gt; function template(block) { block.appendDummyInput() .appendField(new Blockly.FieldTextInput(&apos;default text&apos;), &apos;myText&apos;); } &lt;/script&gt;
</code>
</div>
            </v3d-tabs>
        </li>

        <li>
            <p>multiline - 一个可编辑的多行文本字段</p><img src="files/puzzles/puzzles-plugins-field-text-multiline.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>可以通过 <b>&lt;multiline&gt;</b> 元素嵌套在 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> , <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入中添加。 
<code>
&lt;template&gt;&lt;dummy&gt;&lt;multiline name=&quot;myTextMultiline&quot;&gt;This is a \n multiline \n text&lt;/multiline&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

                <label>JS</label>
                <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a> 方法和 <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldMultilineInput">Blockly.FieldMultilineInput</a> 添加到 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> , <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入。 
<code>
&lt;script&gt; function template(block) { block.appendDummyInput() .appendField(new Blockly.FieldMultilineInput(&apos;This is a \n multiline \n text&apos;), &apos;myTextMultiline&apos;); } &lt;/script&gt;
</code>
</div>
            </v3d-tabs>
        </li>

        <li>
            <p>number - 一个可编辑的数值字段</p><img src="files/puzzles/puzzles-plugins-field-number.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>可以通过 <b>&lt;number&gt;</b> 元素嵌套在 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> , <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入中添加。 
<code>
&lt;template&gt;&lt;dummy&gt;&lt;number name=&quot;myNumber&quot;&gt;3&lt;/number&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

                <label>JS</label>
                <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a> 方法和 <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldNumber">Blockly.FieldNumber</a> 添加到 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> , <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入。 
<code>
&lt;script&gt; function template(block) { block.appendDummyInput() .appendField(new Blockly.FieldNumber(3), &apos;myNumber&apos;); } &lt;/script&gt;
</code>
</div>
            </v3d-tabs>
        </li>

        <li>
            <p>angle - 一个可编辑的字段，用于表示角度的数值（单位：度）。</p><img src="files/puzzles/puzzles-plugins-field-number-angle.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>可以通过 <b>&lt;angle&gt;</b> 元素嵌套在 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> , <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入中添加。 
<code>
&lt;template&gt;&lt;dummy&gt;&lt;angle name=&quot;myAngle&quot;&gt;15&lt;/angle&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

                <label>JS</label>
                <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a> 方法和 <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldAngle">Blockly.FieldAngle</a> 添加到 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> , <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入。 
<code>
&lt;script&gt; function template(block) { block.appendDummyInput() .appendField(new Blockly.FieldAngle(15), &apos;myAngle&apos;); } &lt;/script&gt;
</code>
</div>
            </v3d-tabs>
        </li>

        <li id="block_file_template_adding_fields_checkbox">
            <p>checkbox - 一个典型的复选框字段</p><img src="files/puzzles/puzzles-plugins-field-checkbox.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>可以通过 <b>&lt;checkbox&gt;</b>  元素嵌套在 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>, <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入中添加。默认的复选框状态应该被设置为 *true* 或 *false* 。 
<code>
&lt;template&gt;&lt;dummy&gt;&lt;checkbox name=&quot;myCheckbox&quot;&gt;true&lt;/checkbox&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

                <label>JS</label>
                <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a> 方法和 <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldCheckbox">Blockly.FieldCheckbox</a> 添加到一个 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> , <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入。默认的复选框状态作为参数传递给 *Blockly.FieldCheckbox* ，可以是 *true* 或 *false* 。 
<code>
&lt;script&gt; function template(block) { block.appendDummyInput() .appendField(new Blockly.FieldCheckbox(true), &apos;myCheckbox&apos;); } &lt;/script&gt;
</code>
</div>
            </v3d-tabs>
        </li>

        <li id="block_file_template_adding_fields_dropdown">
            <p>dropdown - 一个可供选择的值的列表</p><img src="files/puzzles/puzzles-plugins-field-dropdown.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>
                    <p>可以通过 <b>&lt;dropdown&gt;</b>  元素嵌套在  <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>, <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a>  输入中添加。</p>
                    <p>为了创建选项列表，在 <b>&lt;dropdown&gt;</b> 内添加 <b>&lt;option&gt;</b> 元素。所有 <b>&lt;option&gt;</b> 元素的 *name* 属性必须设置为一个唯一的标识符（更适合在代码中使用的东西，例如COLOR_GREEN）。在开始和结束的 <b>&lt;option&gt;</b> 标签之间包含的文本被用作该选项的下拉部件中显示的标签。</p>
                    <p>要设置默认选择，可以将选项的 *default* 属性设置为 *true* 。</p>
<code>
&lt;template&gt;&lt;dummy&gt;&lt;dropdown name=&quot;myDropdown&quot;&gt;&lt;option name=&quot;COLOR_GREEN&quot;&gt;green&lt;/option&gt;&lt;option name=&quot;COLOR_YELLOW&quot; default=&quot;true&quot;&gt;yellow&lt;/option&gt;&lt;option name=&quot;COLOR_RED&quot;&gt;red&lt;/option&gt;&lt;/dropdown&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

                <label>JS</label>
                <div>
                    <p>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a> 方法和 <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldDropdown">Blockly.FieldDropdown</a> 添加到 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> 、 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入。</p>
                    <p>*Blockly.FieldDropdown* 的第一个参数可以是一个可用选项的数组。每个选项依次也是一个包含两个元素的数组：一个用于在用户界面中显示文本（表示选项内容的友好提示文本）和一个唯一标识符（更适合在代码中使用的东西，例如COLOR_GREEN）。</p>
                    <p>可以通过调用 <a href="https://developers.google.com/blockly/reference/js/Blockly.Field#setValue">setValue</a> 方法来设置默认选择的选项。要指定哪个是默认的，只需将选项的唯一标识符作为参数传入 *setValue* 。</p>
<code>
&lt;script&gt; function template(block) { let field = new Blockly.FieldDropdown([ // [ displayed text, option name ] [&apos;green&apos;, &apos;COLOR_GREEN&apos;], [&apos;yellow&apos;, &apos;COLOR_YELLOW&apos;], [&apos;red&apos;, &apos;COLOR_RED&apos;], ]); // setting default option field.setValue(&apos;COLOR_YELLOW&apos;); block.appendDummyInput() .appendField(field, &apos;myDropdown&apos;); } &lt;/script&gt;
</code>
</div>
            </v3d-tabs>
        </li>

        <li>
            <p>color picker - 一个颜色选择器部件</p><img src="files/puzzles/puzzles-plugins-field-color.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
                <label>XML</label>
                <div>可以通过 <b>&lt;color&gt;</b> 元素嵌套在  <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a>, <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a>  输入中添加。 
<code>
&lt;template&gt;&lt;dummy&gt;&lt;color name=&quot;myColor&quot;&gt;#350af5&lt;/color&gt;&lt;/dummy&gt;&lt;/template&gt;
</code>
</div>

                <label>JS</label>
                <div>可以通过 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#appendField">appendField</a> 方法和 <a href="https://developers.google.com/blockly/reference/js/Blockly.FieldColour">Blockly.FieldColor</a> 添加到 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_dummy">dummy</a> , <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value</a> 或 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement</a> 输入。 
<code>
&lt;script&gt; function template(block) { block.appendDummyInput() .appendField(new Blockly.FieldColor(&apos;#350af5&apos;), &apos;myColor&apos;); } &lt;/script&gt;
</code>
</div>
            </v3d-tabs>
        </li>
    </ul>

    [anchor:block_file_template_field_alignment]

    <h5>字段排列</h5>

    <div class="indented">
        <p>拼图模块中的字段元素总是属于一个特定的输入插槽。无论是单个字段还是每个输入的多个字段，它们总是按照一定的布局进行渲染。有一件事是可以改变的，那就是字段在输入框中的位置，特别是它们被排列在哪一边。您可以让它们向左（默认）、向右和向中间对齐。</p><img src="files/puzzles/puzzles-plugins-field-alignment.png" class="width-clear border-gray"><v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>要改变某个输入的字段对齐方式，请使用相应的 <a href="manual/zh/puzzles/Plugins.html#block_file_template_block_adding_inputs">输入元素</a> 上的 *align* 属性。这个属性的有效值是：*Left* 、 *center* 和 *right* 。 
<code>
&lt;template&gt;&lt;dummy align=&quot;left&quot;&gt;&lt;/dummy&gt;&lt;value align=&quot;center&quot; name=&quot;myValueInput&quot;&gt;&lt;/value&gt;&lt;statement align=&quot;right&quot; name=&quot;myStatementInput&quot;&gt;&lt;/statement&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>要改变某个输入的字段对齐方式，请使用 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#setAlign">setAlign</a> 方法。它的第一个参数应该是 *Blockly.ALIGN_LEFT* ， *Blockly.ALIGN_CENTER* 或 *Blockly.ALIGN_RIGHT* 。 
<code>
&lt;script&gt; function template(block) { block.appendDummyInput() .setAlign(Blockly.ALIGN_LEFT); block.appendValueInput(&apos;myValueInput&apos;) .setAlign(Blockly.ALIGN_CENTER); block.appendStatementInput(&apos;myStatementInput&apos;) .setAlign(Blockly.ALIGN_RIGHT); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>
    </div>

    [anchor:block_file_template_block_connections]

    <h5>模块的连接</h5>

    <div class="indented">
        <p>拼图模块可以有输入、语句和输出连接。输入连接是为每个创建的输入插槽自动添加的，它的作用是插入子模块。请在这里查看关于创建输入的介绍：<a href="manual/zh/puzzles/Plugins.html#block_file_template_block_adding_inputs">添加输入</a>.*Statement* （previous和next）和 *output* 连接用于将模块连接到父模块或同级模块。</p>
        <p>*previous* 和 *next* 分别在拼图模块的顶部和底部添加连接，因此拼图模块可以从下面/上面连接到其他有匹配连接的模块。</p>
        <p>*output* 在拼图模块的左侧添加了一个连接&mdash;&mdash;这使得该模块可以被插入到父模块的输入插槽中。输出连接通常用于返回数值的拼图模块，例如，一些数学计算的结果。</p>
        <p>默认情况下，一个拼图模块没有任何连接。您可以在一个拼图模块上添加任何类型的单个连接。您也可以在一个拼图模块中添加2个 *statement* 或 *output* 连接，但只允许以下组合：*previous* + *next* 或 *next* + *output*。</p><img src="files/puzzles/puzzles-plugins-output-connections.png" class="width-clear border-gray"><p>如下演示如何将所有这些连接添加到一个模块中：</p>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>可以通过设置 *prev* 属性为 *true* 来启用 *previous* statement连接。 
<code>
&lt;template prev=&quot;true&quot;&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>通过调用 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setPreviousStatement">block.setPreviousStatement</a> ，以 *true* 作为第一个参数，可以启用 *previous* statement连接。 
<code>
&lt;script&gt; function template(block) { block.setPreviousStatement(true); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>可以通过将 *next* 属性设置为 *true* 来启用 *next* statement连接。 
<code>
&lt;template next=&quot;true&quot;&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>可以通过调用 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setNextStatement">block.setNextStatement</a> ，以 *true* 作为第一个参数，来启用 *next* statement连接。 
<code>
&lt;script&gt; function template(block) { block.setNextStatement(true); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>可以通过设置 *output* 属性为空字符串来启用 *output* 连接。 
<code>
&lt;template output=&quot;&quot;&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>可以通过调用 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setOutput">block.setOutput</a> 启用 *output* 连接，并将 *true* 作为第一个参数。 
<code>
&lt;script&gt; function template(block) { block.setOutput(true); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>
    </div>

    [anchor:block_file_template_input_output_type_checking]

    <h5>输入/输出类型检查</h5>

    <div class="indented">
        <p>默认情况下，所有具有合适输入/输出的拼图模块都可以相互连接。但这并不意味着所有的拼图模块都应该是兼容的。比方说，我们有一个拼图模块返回一个坐标数组，而另一个拼图模块有一个期望得到动画名称的输入。如果我们试图将第一个模块插入第二个模块中，那么事情可能不会按预期执行。从这些拼图中产生的代码可能是无效的，甚至可能导致页面崩溃。</p>
        <p>好在有一种方法可以解决此类情况。每一个输入和输出都可以被分配一个类型，只有那些具有匹配类型的模块可以相互连接。</p>
        <p class="note">关于输出和其他连接的常用信息，请参见 <a href="manual/zh/puzzles/Plugins.html#block_file_template_block_connections">模块的连接</a> 。</p>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>输出类型可以通过 <b>&lt;template&gt;</b> 的 *output* 属性来指定。一个特定的输入可以接受的类型是由输入的 *type* 属性定义的。 
<code>
&lt;!-- the block&apos;s output type is &apos;String&apos; --&gt;&lt;template output=&quot;String&quot;&gt;&lt;!-- this input accepts only blocks of type &apos;Number&apos; --&gt;&lt;value name=&quot;myInput&quot; type=&quot;Number&quot;&gt;&lt;/value&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>输出类型可以通过调用 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#setOutput">block.setOutput</a> 方法来分配给一个模块，同时将 *true* 作为其第一个参数，将所需类型作为其第二个参数。通过调用 <a href="https://developers.google.com/blockly/reference/js/Blockly.Input#setCheck">setCheck</a> 方法来设置一个特定输入所能接受的类型。 
<code>
&lt;script&gt; function template(block) { // this input accepts only blocks of type &apos;Number&apos; block.appendValueInput(&apos;myInput&apos;) .setCheck(&apos;Number&apos;); // the block&apos;s output type is &apos;String&apos; block.setOutput(true, &apos;String&apos;); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>

        <p>在上面的例子中，该模块有一个只能接受 &quot;number &quot;类型或未指定类型的模块的输入（如果没有通过 *setOutput* 设置类型）。该模块也有 &quot;String&quot; 输出类型，这意味着它只能插入具有 &quot;String&quot; 或未指定类型的输入（如果没有通过 *setCheck* 设置类型）。</p>
        <p>输入和输出也可以有一个以上的类型。</p>

        <v3d-tabs style="width: 1000px;">
            <label>XML</label>
            <div>为了拥有多个输入/输出类型，请在相应的 *type* 和 *output* 属性中填写多个类型值，并以空格分隔： 
<code>
&lt;!-- this block&apos;s output type is &apos;String&apos; or &apos;Animation&apos; --&gt;&lt;template output=&quot;String Animation&quot;&gt;&lt;!-- this input accepts only blocks of type &apos;Number&apos; or &apos;Object3D&apos; --&gt;&lt;value name=&quot;myInput&quot; type=&quot;Number Object3D&quot;&gt;&lt;/value&gt;&lt;/template&gt;
</code>
</div>

            <label>JS</label>
            <div>为了拥有多个输入/输出类型，在 *setCheck* 和/或 *setOutput* 中提供类型阵列。 
<code>
&lt;script&gt; function template(block) { // this input accepts only blocks of type &apos;Number&apos; or &apos;Object3D&apos; block.appendValueInput(&apos;myInput&apos;) .setCheck([&apos;Number&apos;, &apos;Object3D&apos;]); // this block&apos;s output type is &apos;String&apos; or &apos;Animation&apos; block.setOutput(true, [&apos;String&apos;, &apos;Animation&apos;]); } &lt;/script&gt;
</code>
</div>
        </v3d-tabs>

        <p>标准的Verge3D拼图使用了几种特定的输入/输出类型，您也可以在您的拼图中借用这些类型。</p>
        <ul>
            <li>对于Javascript类型和内置对象，有以下几种：*Number*, *String*, *Boolean*, *Dictionary* (针对js对象), *Array*, *Promise*</li>
            <li>对于场景实体：*Object3D*, *Material*, *Animation*.</li>
            <li>其他类型：*Canvas*, *Sound*, *Video*</li>
        </ul>
        <p>您无需局限于上述类型，我们鼓励您创造自己的输入/输出类型，以更好地适应您的拼图。</p>
    </div>

    [anchor:block_file_code]

    <h4>Code Function</h4>

    <p>*Code()* 函数是用来提供Javascript代码的，如果拼图被添加到工作区，它就会被生成。一般来说，这是您定义拼图逻辑的地方，也是您实现大部分拼图功能的地方。</p>

    <p>该函数预期返回一个包含js代码的字符串。它的工作方式类似于 <a href="manual/zh/puzzles/Plugins.html#init_plug_script">init.plug的代码函数</a> 的工作方式，只是在这种情况下，代码被添加和使用的次数与被添加到工作区的拼图模块的数量相同。这个 *code()* 函数接收一个 *block* 参数&mdash;&mdash;它与在 <a href="manual/zh/puzzles/Plugins.html#block_file_template">template()</a> 中使用的 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg">Blockly.BlockSvg</a> 是同一个实例，。</p>

    <p>一起来看看您能用 *code()* 函数做些什么。</p>

    [anchor:block_file_code_basic_code_generation]

    <h5>基本的代码生成</h5>

    <p class="indented">*code()* 能做的非常简单的事情就是返回一个带有几行 javascript 代码的字符串，这些代码将被添加到生成的 visual_logic.js 文件中。<br/>例如，下面的代码打开了标准的浏览器警报对话框。
<code>
function code(block) { return `alert(&apos;Test&apos;);`; }
</code>
 而在这里，我们只是返回一个为1的值：
<code>
function code(block) { return `1`; }
</code>
 - 这个例子并没有什么意义，除非此模块有输出连接。在这种情况下，返回值可以从一个父模块中访问，该父模块的输入端之一插入了这个模块。<br/><br/>这里是一个更高级的例子：
<code>
function code(block) { const fun = function() { app.scene.traverse(function(obj) { obj.material = new v3d.MeshBasicMaterial({ color: new v3d.Color(Math.random(), Math.random(), Math.random()) }); }); } return `(${fun})();`; }
</code>
 - 这里所有的对象都得到了一个新的材质，其颜色是随机生成的。</p>

    [anchor:block_file_code_mitigating_code_bloat]

    <h5>缓解代码臃肿问题</h5>

    <p class="indented">默认情况下，每次在工作区使用拼图时，拼图的代码都会被复制到生成的visual_logic.js文件中。如果您只有几行代码，这并不是什么问题。但是，如果代码很笨重、很复杂，并且分成几个你可能只想声明一次的函数，那么默认的方法就会变得效率低下，并导致产生的visual_logic.js文件变得臃肿。<br/><br/>为了解决这个问题，您可以利用 *code()* 函数中的一个特殊方法&mdash;&mdash;*Plug.provision()* 。我们通过下方的示例来演示如何使用：
<code>
function code(block) { const fun = Plug.provide(&apos;myFunction&apos;, function(a, b, c) { console.log(a, b, c); }); return `${fun}(1, 2, 3);`; }
</code>
 在这里，我们通过 *Plug.provide()* 定义了一个函数 &quot;myFunction&quot; ，这意味着无论拼图在工作区被使用多少次，&quot;myFunction&quot; 都只会被复制到visual_logic.js中一次。另外，从 *code()* 返回的值只有 <b>${fun}(1, 2, 3);</b> ，这基本上是一个函数调用 <b>&quot;myFunction(1, 2, 3);&quot;</b>  ，它将被插入visual_logic.js中，用于工作区的每个拼图。而这正是我们的拼图所希望的，因为 &quot;myFunction&quot; 只需要声明一次，之后就可以多次调用。<br/><br/>在 *Plug.provide()* 中的第一个参数应该是一个唯一的函数标识符。返回的变量*fun*是所提供的函数的名称（它通常与第一个参数传递的值几乎相同，但也可以不同，因为拼图编辑器需要确保这个名称是有效的，并且与工作区使用的其他函数/变量没有冲突）。应该使用该名称（而不是原始的&ldquo;myFunction&rdquo;）来调用提供的函数 - 这就是它在 return 语句下的部分中的完成方式。<br/><br/></p>

    [anchor:block_file_code_inputs_fields]

    <h5>访问输入和字段</h5>

    <p class="indented">如果一个拼图模块有 <a href="manual/zh/puzzles/Plugins.html#block_file_template_adding_fields">fields</a> 或 <a href="manual/zh/puzzles/Plugins.html#block_file_template_block_adding_inputs">input slots</a> 在 <a href="manual/zh/puzzles/Plugins.html#block_file_template">template()</a> 函数中定义，那么您很可能希望它们影响 *code()* 函数内生成的内容。例如， <a href="manual/zh/puzzles/Plugins.html#block_file_template_adding_fields_checkbox">复选框</a> 可以启用或禁用您的拼图的某个功能。<br/><br/>用于访问 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_value">value inputs</a> 、 <a href="manual/zh/puzzles/Plugins.html#adding_inputs_statement">statement inputs</a> 和 <a href="manual/zh/puzzles/Plugins.html#block_file_template_adding_fields">fields</a> 的API方法有：<a href="https://developers.google.com/blockly/reference/js/Blockly.Generator#valueToCode">Blockly.JavaScript.valueToCode</a> , <a href="https://developers.google.com/blockly/reference/js/Blockly.Generator#statementToCode">Blockly.JavaScript.statementToCode</a> 和 <a href="https://developers.google.com/blockly/reference/js/Blockly.BlockSvg#getFieldValue">block.getFieldValue</a> 。<br/><br/>让我们做一个既有输入又有字段的拼图模块。下面是.block文件的全部内容：
<code>
&lt;template color=&quot;green&quot;&gt;&lt;dummy&gt;&lt;label&gt;myPuzzle&lt;/label&gt;&lt;/dummy&gt;&lt;value name=&quot;myValue&quot;&gt;&lt;/value&gt;&lt;statement name=&quot;myStatement&quot;&gt;&lt;/statement&gt;&lt;dummy&gt;&lt;checkbox name=&quot;myCheckbox&quot;&gt;true&lt;/checkbox&gt;&lt;/dummy&gt;&lt;/template&gt;&lt;script&gt; function wrapFn(contents) { return `function() {${contents}}`; } function code(block) { const myInput = Blockly.JavaScript.valueToCode(block, &apos;myValue&apos;, Blockly.JavaScript.ORDER_NONE) || `&apos;&apos;`; const myStatement = wrapFn(Blockly.JavaScript.statementToCode(block, &apos;myStatement&apos;)); const myCheckbox = block.getFieldValue(&apos;myCheckbox&apos;) === &apos;TRUE&apos;; const fun = Plug.provide(&apos;myFunction&apos;, function(input, statements, checkbox) { console.log(&apos;input value:&apos;, input); statements(); // execute puzzles from the myStatement input console.log(&apos;checkbox state:&apos;, checkbox); }); return `${fun}(${myInput}, ${myStatement}, ${myCheckbox});`; } &lt;/script&gt;
</code>
 在这个例子中，该模块定义了一个名为 &quot;myValue&quot; 的数值输入，一个语句输入 &quot;myStatement&quot; 和一个复选框字段 &quot;myCheckbox&quot;。我们通过上面描述的API获得它们的值，但在将它们传入 &quot;myFunction &quot;之前，它们经历了一些值得注意的变化。
<code>
var myInput = Blockly.JavaScript.valueToCode(block, &apos;myValue&apos;, Blockly.JavaScript.ORDER_NONE) || `&apos;&apos;`;
</code>
 - 输入插槽可能会没有插入模块，所以我们通过在末尾添加*|| `&apos;&apos;*部分，来确保在这种情况下可以得到一个空字符串。
<code>
function wrapFn(contents) { return `function() {${contents}}`; } ... var myStatement = wrapFn(Blockly.JavaScript.statementToCode(block, &apos;myStatement&apos;));
</code>
 - Statement输入插槽通常包含一组Statement。把它们包在一个函数中是很方便的（见 *wrapFn* 的作用），以便把该函数对象作为参数传递，然后把它当作一个回调使用。
<code>
var myCheckbox = block.getFieldValue(&apos;myCheckbox&apos;) === &apos;TRUE&apos;;
</code>
 - 在这里，复选框的值只用于与 &quot;TRUE&quot; 进行比较，产生一个布尔值的结果。<br/><br/>最后，所有的值都可以传递给 &quot;myFunction&quot; ，如下所示：
<code>
return `${fun}(${myInput}, ${myStatement}, ${myCheckbox});`;
</code>
 现在您能够随心所欲地使用它们了。 
<code>
const fun = Plug.provide(&apos;myFunction&apos;, function(input, statements, checkbox) { console.log(&apos;input value:&apos;, input); statements(); // execute puzzles from the myStatement input console.log(&apos;checkbox state:&apos;, checkbox); });
</code>
</p>

    [anchor:%TOC_DECLEVEL_HACK]

    <h1></h1>

    [anchor:%TOC_DECLEVEL_HACK]

    <h1></h1>

    [anchor:plugin_errors]

    <h2>插件和图模块的错误</h2>

    <p>在开发或使用插件时，您可能会遇到不同类型的错误，与某个拼图模块或与整个插件有关。本节将介绍典型的插件和拼图模块错误，以及如何处理这些问题。</p>

    <p>如果在加载插件或初始化拼图模块的过程中出现错误，那么拼图编辑器会在浏览器控制台中打印出相应的错误信息。通常情况下，这些错误会像下面这样：</p>

    <p class="code red">PluginError(PLUGIN_NAME) ...<br/>BlockError(PLUGIN_NAME/BLOCK_NAME) ...<br/>Puzzle &quot;PLUGIN_NAME/BLOCK_NAME&quot; is not defined properly.Replaced with a dummy block.</p>

    <p>- 它们指的是一个特定的插件和一个特定模块导致的错误。</p>

    <p>在插件出错的情况下，整个插件的类目很可能都不会在工具箱中显示。如果是拼图模块错误，受影响的拼图模块将被标记为无效，并有一个明显的外观标示：</p><img src="files/puzzles/puzzles-plugins-dummy-block.jpg" id="dummy_block_appearance" class="centered" style="max-width: 852px"> <span class="img-caption">在工具箱和工作区中的无效拼图</span><p>以下是最常见的插件和拼图模块错误的列表：</p><br/> [anchor:plugin_errors_block_error_parsing_0]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): error parsing .block file - &quot;This page contains the following errors:error on line ...&quot;</h5>
    <p class="indented">这意味着在相应的.block文件中存在着XML错误，使其无法被解析。例如，缺少结尾的&lt;script&gt;标签会导致这样的错误。 
<code>
&lt;script&gt; function template(block) {} function code(block) {}
</code>
</p><br/> [anchor:plugin_errors_block_error_parsing_1]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): error parsing .block file - &quot;ReferenceError (SyntaxError, TypeError, etc...)...&quot;</h5>
    <p class="indented">这代表着相应的.block文件的&lt;script&gt;元素中的代码包含错误信息中指定的JavaScript错误。</p><br/> [anchor:plugin_errors_block_error_validation_0]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): validation error - &quot;TypeError: Child block does not have output or previous statement.&quot;</h5>
    <p class="indented">这个错误所指的模块有一个子模块插入其中。但是，这个子模块没有 <a href="manual/zh/puzzles/Plugins.html#block_file_template_block_connections">输出或前一个连接</a> ，因此不能以这种方式使用。这种情况可能发生在插件的工具箱 <a href="manual/zh/puzzles/Plugins.html#init_plug_category">类目</a> 中的拼图块，因为它们是在init.plug中配置的，也可能发生在工作区实际使用的块上。</p><br/> [anchor:plugin_errors_block_error_validation_1]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): validation error - &quot;Error: Connection checks failed.Input &quot;PARENT_INPUT_NAME&quot; connection on &quot;PLUGIN_NAME/BLOCK_NAME&quot; block (id=&quot;BLOCK_ID&quot;) expected TYPE_PARENT, found TYPE_CHILD&quot;</h5>
    <p class="indented">这个错误所指的模块有一个子模块插入其中，但是父模块的输入插槽和子模块的输出连接的 <a href="manual/zh/puzzles/Plugins.html#block_file_template_input_output_type_checking">类型</a> 不兼容。这种情况可能发生在插件的工具箱 <a href="manual/zh/puzzles/Plugins.html#init_plug_category">类目</a> 中的拼图块，因为它们是在init.plug中配置的，也可能发生在工作区实际使用的块上。</p><br/> [anchor:plugin_errors_block_error_validation_2]

    <h5>BlockError(PLUGIN_NAME/null): validation error - &quot;TypeError: Unknown block type: PLUGIN_NAME/null&quot;</h5>
    <p class="indented">这个错误意味着该插件的init.plug文件引用了一个没有指定 <a href="manual/zh/puzzles/Plugins.html#init_plug_available_puzzles">类型属性</a> 的模块，这是不允许的。例如，这样做是行不通的： 
<code>
&lt;category name=&quot;My Awesome Plugin&quot; color=&quot;green&quot;&gt;&lt;block&gt;&lt;/block&gt;&lt;/category&gt;
</code>
</p><br/> [anchor:plugin_errors_block_error_validation_3]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): validation error - &quot;TypeError: Unknown block type: PLUGIN_NAME/BLOCK_NAME&quot;</h5>
    <p class="indented">这个错误信息通常出现在一个 <a href="manual/zh/puzzles/Plugins.html#plugin_errors_block_error_parsing_0">&quot;错误解析的 .block文件&quot;</a> 的错误之后，它表明由于最初的错误，提到的拼图模块没有被正确加载和初始化。</p><br/> [anchor:plugin_errors_block_error_template]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): error calling template() function ...</h5>
    <p class="indented">相应的.block文件要么有一个定义不正确的 <a href="manual/zh/puzzles/Plugins.html#block_file_template">&lt;template&gt;</a> 元素，要么在其 <a href="manual/zh/puzzles/Plugins.html#block_file_template">template()</a> 函数中包含JavaScript错误。<ul>
            <li><b>BlockError(PLUGIN_NAME/BLOCK_NAME): error calling template() function - &quot;TypeError: Found invalid FieldDropdown options.&quot;</b><br/>这个特殊的错误意味着拼图中的一个下拉字段有一个未命名的选项。参见 <a href="manual/zh/puzzles/Plugins.html#block_file_template_adding_fields_dropdown">dropdown field</a> 以了解更多信息。</li>
        </ul>
    </p><br/> [anchor:plugin_errors_block_error_code]

    <h5>BlockError(PLUGIN_NAME/BLOCK_NAME): error calling code() function ...</h5>
    <p class="indented">相应的.block文件在其 <a href="manual/zh/puzzles/Plugins.html#block_file_code">code()</a> 函数内含有JavaScript错误。</p><br/> [anchor:plugin_errors_plugin_error_parsing_0]

    <h5>PluginError(PLUGIN_NAME): error parsing init.plug file - &quot;This page contains the following errors:error on line ...&quot;</h5>
    <p class="indented">这意味着在插件的init.plug文件中存在着XML错误，使其无法被解析。例如，缺少结尾的&lt;category&gt;标签会导致这样的错误。 
<code>
&lt;category name=&quot;MyAwesomePlugin&quot; color=&quot;green&quot;&gt;&lt;block type=&quot;myPuzzle&quot;&gt;&lt;/block&gt;
</code>
</p><br/> [anchor:plugin_errors_plugin_error_parsing_1]

    <h5>PluginError(PLUGIN_NAME): error parsing init.plug file - &quot;ReferenceError (SyntaxError, TypeError, etc...)...&quot;</h5>
    <p class="indented">这意味着如果相应的init.plug文件的&lt;script&gt;元素中的代码包含错误信息中指定的JavaScript错误。</p><br/> [anchor:plugin_errors_plugin_error_code]

    <h5>PluginError(PLUGIN_NAME): error calling code() function ...</h5>
    <p class="indented">该插件的init.plug文件在其 <a href="manual/zh/puzzles/Plugins.html#init_plug_script">code()</a> 函数内含有JavaScript错误。</p><br/> [anchor:plugin_errors_dummy]

    <h5>Puzzle &quot;PLUGIN_NAME/BLOCK_NAME&quot; is not defined properly.Replaced with a dummy block.</h5>
    <p class="indented">这条错误信息通常出现在一个BlockError和/或PluginError错误信息之后，它表明由于原始错误，提到的拼图模块没有被正确加载和初始化。为了仍然能够加载拼图并在一定程度上保持其可操作性，这样的拼图模块（无论是在插件的工具箱类目中还是在工作区中）都会被特殊的dummy模块所取代。Dummy模块的例子见 <a href="manual/zh/puzzles/Plugins.html#dummy_block_appearance">这张图片</a> 。</p><br/> [anchor:sharing_your_plugin]

    <h2>分享您的插件</h2>

    <p>一旦插件开发完成并经过测试，请随时通过以下方式分享。</p>

    <ul>
        <li>在 <a href="https://www.soft8soft.com/forum/plugins/" target="_blank">Verge3D论坛上发布链接</a>。</li>
        <li>如果您希望能在 <a href="manual/zh/introduction/Useful-links.html#third_party_plugins">常用链接</a> 章节中被提及，请<a href="https://www.soft8soft.com/contact/" target="_blank">联系我们</a>！</li>
        <li>在社交媒体上分享是使用 <strong>#verge3d</strong> 标签。</li>
        <li>在 <a href="https://gumroad.com/" target="_blank">Gumroad</a> 或类似的资源网站上发布。</li>
    </ul>


    <h2>在使用拼图时遇到困难？</h2>

    <p>欢迎您随时在 <a href="https://www.soft8soft.com/forums/" target="_blank">论坛</a>上提问！您还可以加入中文用户社区<a href="https://shang.qq.com/wpa/qunwpa?idkey=c31cf6597f3ed7ce68bd47aba6bba23049bf973ac6acc59b0a5a7d1bd933b3ea" target="_blank">QQ群(171678760)</a>，在线寻求帮助。</p>

  </article></body>
</html>
