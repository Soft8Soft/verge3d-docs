<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <base href="../../../" />
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css" />
  </head>
  <body>
    <h1>[name]</h1>

    <p class="desc">
      Рендерер WebGL отображает ваши великолепно выполненные сцены, используя
      [link:https://en.wikipedia.org/wiki/WebGL WebGL].
    </p>

    <h2>Конструктор</h2>

    <h3>[name]([param:Object parameters])</h3>
    <p>
    [page:Object parameters] - (необязательный) объект со свойствами, определяющими поведение рендерера.
    Конструктор также не принимает никаких параметров. Во всех случаях он будет принимать разумные значения по умолчанию
    если параметры отсутствуют. Ниже перечислены допустимые параметры:<br /><br />

    [page:DOMElement canvas] - [link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas]
    где рендерер выводит свои результат.
    Это соответствует приведенному ниже свойству [page:WebGLRenderer.domElement domElement].
    Если не передать этот параметр, будет создан новый элемент canvas.<br />


    [page:WebGLRenderingContext context] - Может быть использован для присоединения рендерера к существующему
    [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext].
    По умолчанию null.<br />

    [page:String precision] - Точность шейдера. Может быть *"highp "*, *"mediump "* или *"lowp "*.
    По умолчанию *"highp "*, если поддерживается устройством. Смотрите заметку "Things to Avoid"
    [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices здесь].<br />

    [page:Boolean alpha] - содержит ли canvas альфа-буфер (прозрачность) или нет.
    По умолчанию *false*.<br />

    [page:Boolean premultipliedAlpha] - будет ли рендерер считать, что цвета имеют
    [link:https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#Premultiplied_alpha premultiplied alpha].
    По умолчанию *true*.<br />

    [page:Boolean antialias] - выполнять ли сглаживание. По умолчанию *false*.<br />

    [page:Boolean stencil] - имеет ли буфер отрисовки
    [link:https://en.wikipedia.org/wiki/Stencil_buffer stencil buffer] как минимум 8 бит.
    По умолчанию *true*.<br />

    [page:Boolean preserveDrawingBuffer] - сохранять ли буферы до тех пор, пока они не будут очищены вручную
    или перезаписаны По умолчанию *false*.<br />

    [page:String powerPreference] - Предоставляет агенту пользователя подсказку, указывающую, какая конфигурация GPU подходит для данного контекста WebGL.
    Может быть *"high-performance"*, *"low-power"* или *"default"*. По умолчанию *"default"*.
    См. [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2 WebGL spec] для подробностей.<br />

    [page:Boolean failIfMajorPerformanceCaveat] - будет ли создание рендерера завершено при обнаружении низкой производительности. По умолчанию *false*.
    См. [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2 WebGL spec] для подробностей.<br />

    [page:Boolean depth] - имеет ли буфер отрисовки иметь
    [link:https://en.wikipedia.org/wiki/Z-buffering depth buffer] как минимум 16 бит.
    По умолчанию *true*.<br />

    [page:Boolean logarithmicDepthBuffer] -  использовать ли логарифмический буфер глубины. может потребоваться при работе с большими различиями в масштабе в одной сцене.
    Обратите внимание, что эта настройка использует gl_FragDepth, который отключает оптимизацию [link:https://www.khronos.org/opengl/wiki/Early_Fragment_Test Early Fragment Test]
    и может привести к снижению производительности.
    По умолчанию *false*. Ознакомьтесь с примером [example:webgl_camera_logarithmicdepthbuffer camera / logarithmicdepthbuffer].
    </p>

    <h2>Свойства</h2>

    <h3>[property:Boolean autoClear]</h3>
    <p>Определяет, должен ли рендерер автоматически очищать свой вывод перед рендерингом кадра.</p>


    <h3>[property:Boolean autoClearColor]</h3>
    <p>
      Если [page:.autoClear autoClear] равно true, определяет, должен ли рендерер очищать буфер цвета. По умолчанию *true*.
    </p>


    <h3>[property:Boolean autoClearDepth]</h3>
    <p>
      Если [page:.autoClear autoClear] равно true, определяет, должен ли рендерер очищать буфер глубины. По умолчанию *true*.
    </p>


    <h3>[property:Boolean autoClearStencil]</h3>
    <p>
      Если [page:.autoClear autoClear] равно true, определяет, должен ли рендерер очищать буфер стенсила. По умолчанию *true*.
    </p>

    <h3>[property:Boolean debug.checkShaderErrors]</h3>
    <p>
      Если [page:.checkShaderErrors checkShaderErrors] равно true, определяет, проверяются ли программы шейдеров материалов на наличие ошибок в процессе компиляции и компоновки. Может быть полезно отключить эту проверку во время разработки для повышения производительности.
      Настоятельно рекомендуется включать эти проверки во время разработки. 
      Если шейдер не компилируется и не связывается - он не будет работать и связанный с ним материал не будет рендериться. 
      По умолчанию *true*.
    </p>

    <h3>[property:Object capabilities]</h3>
    <p>
      Объект, содержащий подробную информацию о возможностях текущего [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext].<br />

    - [page:Boolean floatFragmentTextures]: поддерживает ли контекст расширение [link:https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float OES_texture_float].
      Согласно [link:https://webglstats.com/ WebGLStats], по состоянию на февраль 2016 года более 95% устройств с поддержкой WebGL поддерживают эту функцию.<br />
    - [page:Boolean floatVertexTextures]: *true* если [page:Boolean floatFragmentTextures] и [page:Boolean vertexTextures] оба true.<br />
    - [page:Method getMaxAnisotropy](): Возвращает максимальную доступную анизотропию.<br />
    - [page:Method getMaxPrecision](): Возвращает максимальную доступную точность для вершинных и фрагментных шейдеров.<br />
    - [page:Boolean isWebGL2]: *true* если используемый контекст является объектом WebGL2RenderingContext.<br />
    - [page:Boolean logarithmicDepthBuffer]: *true* если [page:parameter logarithmicDepthBuffer] было установлено true в конструкторе и контекст поддерживает расширение[link:https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth EXT_frag_depth].
      Согласно [link:https://webglstats.com/ WebGLStats], по состоянию на февраль 2016 года около 66% устройств с поддержкой WebGL поддерживают эту функцию.<br />
    - [page:Integer maxAttributes]: Значение *gl.MAX_VERTEX_ATTRIBS*.<br />
    - [page:Integer maxCubemapSize]: Значение *gl.MAX_CUBE_MAP_TEXTURE_SIZE*.
    Максимальная высота * ширина текстур карты куба, которые может использовать шейдер.<br />
    - [page:Integer maxFragmentUniforms]: Значение *gl.MAX_FRAGMENT_UNIFORM_VECTORS*.
    Количество uniform, которые может использовать фрагментный шейдер.<br />
    - [page:Integer maxTextureSize]: Значение *gl.MAX_TEXTURE_SIZE*.
    Максимальная высота * ширина текстуры, которую использует шейдер.<br />
    - [page:Integer maxTextures]: Значение *gl.MAX_TEXTURE_IMAGE_UNITS*.
    Максимальное количество текстур, которое может быть использовано шейдером.<br />
    - [page:Integer maxVaryings]: Значение *gl.MAX_VARYING_VECTORS*.
    Количество изменяющихся векторов, которые могут использоваться шейдерами.<br />
    - [page:Integer maxVertexTextures]: Значение *gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS*.
    Количество текстур, которые могут быть использованы в вершинном шейдере.<br />
    - [page:Integer maxVertexUniforms]: Значение *gl.MAX_VERTEX_UNIFORM_VECTORS*.
    Максимальное количество форм, которое может быть использовано в вершинном шейдере.<br />
    - [page:String precision]: The shader precision currently being used by the renderer.<br />
    - [page:Boolean vertexTextures]: *true* если [property:Integer maxVertexTextures] больше чем 0 (т.е. можно использовать вершинные текстуры).<br />
    </p>

    <h3>[property:Array clippingPlanes]</h3>
    <p>
      Определяемые пользователем плоскости сечения, заданные как объекты v3d.Plane в мировом пространстве. Эти плоскости применяются глобально.Точки в пространстве, чье скалярное произведение с плоскостью отрицательно, отсекаются.  По умолчанию []. 
    </p>

    <h3>[property:DOMElement domElement]</h3>
    <p>
    [link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas] где рендерер рисует свой вывод.<br />
    Он автоматически создается рендерером в конструкторе (если он еще не создан); вам просто нужно добавить его на вашу страницу, как показано ниже:<br />
    <code>
      document.body.appendChild(renderer.domElement);
    </code>
    </p>

    <h3>[property:Object extensions]</h3>
    <p>
      Обертка для метода [page:WebGLRenderer.extensions.get .extensions.get], используемого для проверки поддержки различных расширений WebGL.
    </p>

    <h3>[property:Float gammaFactor]</h3>
    <p>По умолчанию *2*. </p>

    <h3>[property:number outputEncoding]</h3>
    <p>Определяет выходную кодировку рендерера. По умолчанию [page:Textures v3d.LinearEncoding].</p>
    <p>Если цель рендеринга была установлена с помощью [page:WebGLRenderer.setRenderTarget .setRenderTarget], то вместо нее будет использоваться renderTarget.texture.encoding.</p>
    <p>Подробности о других форматах смотрите на странице [page:Textures texture constants].</p>

    <h3>[property:Object info]</h3>
    <p>Объект, содержащий ряд статистических сведений о памяти графической карты и процессе рендеринга. Полезен для отладки или просто как дополнительная информация. Объект содержит следующие поля:</p>
    <p>
    <ul>
      <li>memory:
        <ul>
          <li>geometries</li>
          <li>textures</li>
        </ul>
      </li>
      <li>render:
        <ul>
          <li>calls</li>
          <li>triangles</li>
          <li>points</li>
          <li>lines</li>
          <li>frame</li>
        </ul>
      </li>
      <li>programs
      </li>
    </ul>
    </p>
    <p>По умолчанию эти данные сбрасываются при каждом вызове рендеринга, но при наличии нескольких проходов рендеринга на кадр (например, при использовании постобработки) может быть предпочтительнее сбрасывать данные с помощью пользовательского шаблона. Сначала установите *autoReset* в значение *false*.
    <code>
    renderer.info.autoReset = false;
    </code>
    Вызывайте *reset()* каждый раз, когда вы закончили рендеринг одного кадра.
    <code>
    renderer.info.reset();
    </code>
    </p>

    <h3>[property:Boolean localClippingEnabled]</h3>
    <p>Определяет, соблюдает ли рендерер плоскости обтравки на уровне объекта. По умолчанию *false*.</p>

    <h3>[property:Integer maxMorphTargets]</h3>
    <p>
    <!-- Verge3D -->
    По умолчанию 12. Максимальное количество целей MorphTargets, допустимое в шейдере. Следует помнить, что стандартные материалы допускают только 12 целей MorphTargets.
    </p>

    <h3>[property:Integer maxMorphNormals]</h3>
    <p>
    <!-- Verge3D -->
    По умолчанию - 6. Максимальное количество MorphNormals, допустимое в шейдере. Следует помнить, что стандартные материалы допускают только 6 MorphNormals.
    </p>

    <h3>[property:Boolean physicallyCorrectLights]</h3>
    <p>
      Использовать ли режим физически корректного освещения. По умолчанию *false*.
      Смотрите пример [example:webgl_lights_physical lights / physical].
    </p>

    <h3>[property:Object properties]</h3>
    <p>
      Используется внутри рендерера для отслеживания различных свойств саб-объектов.
    </p>

    <h3>[property:WebGLRenderLists renderLists]</h3>
    <p>
      Используется внутренне для обработки упорядочивания рендеринга объектов сцены.
    </p>

    <h3>[property:WebGLShadowMap shadowMap]</h3>
    <p>
      Содержит ссылку на карту теней, если она используется.
    </p>

    <h3>[property:Boolean shadowMap.enabled]</h3>
    <p>Если задано, используйте карты теней в сцене. По умолчанию *false*.</p>

    <h3>[property:Boolean shadowMap.autoUpdate]</h3>
    <p>Включает автоматическое обновление теней в сцене. По умолчанию *true*.</p>
    <p>Если вам не требуется динамическое освещение/тени, вы можете установить значение *false* при инстанцировании рендерера.</p>

    <h3>[property:Boolean shadowMap.needsUpdate]</h3>
    <p>Если установлено значение *true*, карты теней в сцене будут обновлены в следующем вызове *render*. По умолчанию *false*. </p>
    <p>Если вы отключили автоматическое обновление карт теней (*shadowMap.autoUpdate = false*), вам нужно установить значение *true* и затем выполнить вызов рендеринга для обновления теней в вашей сцене.</p>

    <h3>[property:Integer shadowMap.type]</h3>
    <!-- Verge3D -->
    <p>Определяет тип карты теней (нефильтрованная, фильтрация с процентным приближением, фильтрация с процентным приближением с билинейной фильтрацией в шейдере, экспоненциальное отображение теней с гауссовым размытием).</p>
    <p>Варианты: v3d.BasicShadowMap, v3d.PCFShadowMap (по умолчанию), v3d.PCFSoftShadowMap, v3d.ESMShadowMap, v3d.PCFShadowMapPoissonDisk. Подробности смотрите в [page:Renderer Renderer constants].</p>

    <h3>[property:Boolean sortObjects]</h3>
    <p>
    Определяет, должен ли рендерер сортировать объекты. По умолчанию *true*.<br /><br />

    Примечание: Сортировка используется для того, чтобы попытаться правильно отобразить объекты, имеющие некоторую степень прозрачности. По определению, сортировка объектов может работать не во всех случаях. В зависимости от потребностей приложения, может потребоваться отключить сортировку и использовать другие методы для работы с рендерингом прозрачности, например, вручную определять порядок рендеринга каждого объекта.
    </p>

    <h3>[property:Object state]</h3>
    <p>
      Содержит функции для установки различных свойств состояния [page:WebGLRenderer.context].
    </p>

    <h3>[property:Constant toneMapping]</h3>
    <p>
      По умолчанию [page:Renderer NoToneMapping]. Другие варианты смотрите в [page:Renderer Renderer constants].
    </p>

    <h3>[property:Number toneMappingExposure]</h3>
    <p>
      Уровень экспозиции тонального маппинга. По умолчанию *1*.
    </p>

    <h3>[property:WebXRManager xr]</h3>
    <p>
      Предоставляет доступ к связанному с WebXR [page:WebXRManager interface] рендереру.
    </p>

    <h2>Методы</h2>

    <h3>[method:null clear]([param:Boolean color], [param:Boolean depth], [param:Boolean stencil])</h3>
    <p>
      Дает команду рендереру очистить буфер(ы) цвета, глубины или трафаретного рисунка. Этот метод инициализирует буфер цвета текущим значением clear color.
       <br />
       Аргументы по умолчанию имеют значение *true*.
    </p>

    <h3>[method:null clearColor]()</h3>
    <p>Очистить цветовой буфер. Эквивалентно вызову [page:WebGLRenderer.clear .clear](true, false, false).</p>

    <h3>[method:null clearDepth]()</h3>
    <p>Очистить буфер глубины. Эквивалентно вызову [page:WebGLRenderer.clear .clear](false, true, false).</p>

    <h3>[method:null clearStencil]()</h3>
    <p>Очистить буферы стенсилов. Эквивалентно вызову [page:WebGLRenderer.clear .clear](false, false, true).</p>

    <h3>[method:null compile]([param:Object3D scene], [param:Camera camera])</h3>
    <p>Компилирует все материалы в сцене с камерой. Это полезно для предварительной компиляции шейдеров перед первым рендерингом.</p>

    <!-- Verge3D method -->
    <h3>[method:null compileAsync]([param:Scene scene], [param:Camera camera], [param:Function progressCb])</h3>
    <p>
      Асинхронно компилирует все материалы в сцене с камерой. Это полезно для предварительной компиляции шейдеров перед первым рендерингом. Дополнительная функция *progressCb* получает параметр *percentage*.
    </p>

    <h3>[method:null copyFramebufferToTexture]([param:Vector2 position], [param:Texture texture], [param:Number level])</h3>
    <p>Копирует пиксели из текущего WebGLFramebuffer в 2D текстуру. Позволяет получить доступ к [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/copyTexImage2D WebGLRenderingContext.copyTexImage2D].</p>

    <h3>[method:null copyTextureToTexture]([param:Vector2 position], [param:Texture srcTexture], [param:Texture dstTexture], [param:Number level])</h3>
    <p>Копирует все пиксели текстуры в существующую текстуру, начиная с заданной позиции. Позволяет получить доступ к [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texSubImage2D WebGLRenderingContext.texSubImage2D].</p>

    <h3>[method:null dispose]()</h3>
    <p>Удаление текущего контекста рендеринга.</p>

    <h3>[method:Object extensions.get]([param:String extensionName])</h3>
    <p>
      Используется для проверки поддержки различных расширений и возвращает объект с подробной информацией о расширении, если оно доступно.
      Этот метод может проверить наличие следующих расширений:<br /><br />

    - *WEBGL_depth_texture*<br />
    - *EXT_texture_filter_anisotropic*<br />
    - *WEBGL_compressed_texture_s3tc*<br />
    - *WEBGL_compressed_texture_pvrtc*<br />
    - *WEBGL_compressed_texture_etc1*
    </p>

    <h3>[method:null forceContextLoss]()</h3>
    <p>
      Имитация потери контекста WebGL. Для этого требуется поддержка расширения
      [link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context].
      Согласно [link:https://webglstats.com/ WebGLStats], по состоянию на февраль 2016 года 90% устройств с поддержкой WebGL поддерживают его.
    </p>

    <h3>[method:Float getClearAlpha]()</h3>
    <p>Возвращает [page:Float float] с текущей чистой альфой. Диапазон от 0 до 1.</p>

    <h3>[method:Color getClearColor]([param:Color target])</h3>
    <p>Возвращает экземпляр [page:Color v3d.Color] с текущим цветом прозрачности.</p>

    <h3>[method:WebGLRenderingContext getContext]()</h3>
    <p>Возвращает текущий контекст WebGL.</p>

    <h3>[method:WebGLContextAttributes getContextAttributes]()</h3>
    <p>Возвращает объект, описывающий атрибуты, установленные для контекста WebGL при его создании.</p>

    <h3>[method:Integer getActiveCubeFace]()</h3>
    <p>Возвращает текущую активную грань куба.</p>

    <h3>[method:Integer getActiveMipmapLevel]()</h3>
    <p>Возвращает текущий активный уровень mipmap.</p>

    <h3>[method:RenderTarget getRenderTarget]()</h3>
    <p>Возвращает текущую [page:RenderTarget RenderTarget], если она есть; в противном случае возвращает *null*.</p>

    <h3>[method:Vector4 getCurrentViewport]([param:Vector4 target])</h3>
    <p>
    [page:Vector4 target] — результат будет скопирован в этот Vector4.<br /><br />

    Возвращает текущий видовой экран.
    </p>

    <h3>[method:Vector2 getDrawingBufferSize]([param:Vector2 target])</h3>
    <p>
    [page:Vector2 target] — результат будет скопирован в этот Vector2.<br /><br />

    Возвращает ширину и высоту буфера отрисовки рендерера, в пикселях.
    </p>

    <h3>[method:number getPixelRatio]()</h3>
    <p>Возвращает текущее используемое соотношение пикселей устройства.</p>

    <h3>[method:Vector4 getScissor]([param:Vector4 target])</h3>
    <p>
    [page:Vector4 target] — результат будет скопирован в этот Vector4.<br /><br />

    Возвращает область ножниц.
    </p>

    <h3>[method:Boolean getScissorTest]()</h3>
    <p>Возвращает *true*, если тест ножниц включен; возвращает *false* в противном случае.</p>

    <h3>[method:Vector2 getSize]([param:Vector2 target])</h3>
    <p>
    [page:Vector2 target] — результат будет скопирован в этот Vector2.<br /><br />

    Возвращает ширину и высоту выходного холста рендерера, в пикселях.
    </p>

    <h3>[method:Vector4 getViewport]([param:Vector4 target])</h3>
    <p>
    [page:Vector4 target] — результат будет скопирован в этот Vector4.<br /><br />

    Возвращает область просмотра.
    </p>

    <h3>[method:null initTexture]([param:Texture texture])</h3>
    <p> Инициализирует заданную текстуру. Полезно для предварительной загрузки текстуры вместо ожидания первого рендера (который может вызвать заметные задержки из-за накладных расходов на декодирование и загрузку GPU).</p>

    <h3>[method:null resetGLState]()</h3>
    <p>Сброс состояния GL на значение по умолчанию. Вызывается внутренне, если контекст WebGL потерян.</p>

    <h3>[method:null readRenderTargetPixels]([param:WebGLRenderTarget renderTarget], [param:Float x], [param:Float y], [param:Float width], [param:Float height], [param:TypedArray buffer], [param:Integer activeCubeFaceIndex])</h3>
    <p>buffer - Uint8Array - единственный тип назначения, поддерживаемый во всех случаях, другие типы зависят от renderTarget и платформы. Подробности смотрите в [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12 WebGL spec].</p>
    <p>Считывает пиксельные данные из renderTarget в переданный вам буфер. Это обертка вокруг [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels WebGLRenderingContext.readPixels]().</p>
    <p>Смотрите пример [example:webgl_interactive_cubes_gpu interactive / cubes / gpu].</p>
    <p>Для считывания [page:WebGLCubeRenderTarget WebGLCubeRenderTarget] используйте необязательный параметр activeCubeFaceIndex, чтобы определить, какая грань должна быть считана.</p>


    <h3>[method:null render]([param:Object3D scene], [param:Camera camera])</h3>
    <p>
      Рендеринг [page:Scene scene] или другого типа [page:Object3D object] с помощью [page:Camera camera].<br />

      Рендеринг выполняется на ранее указанную [page:WebGLRenderTarget renderTarget], установленную вызовом [page:WebGLRenderer.setRenderTarget .setRenderTarget] или на холст, как обычно.<br />

      По умолчанию буферы рендеринга очищаются перед рендерингом, но вы можете предотвратить это, установив свойство [page:WebGLRenderer.autoClear autoClear] в false.
      Если вы хотите предотвратить очистку только определенных буферов, вы можете установить для свойств [page:WebGLRenderer.autoClearColor autoClearColor], [page:WebGLRenderer.autoClearStencil autoClearStencil] или [page:WebGLRenderer.autoClearDepth autoClearDepth] значение false. Чтобы принудительно очистить один или несколько буферов, вызовите [page:WebGLRenderer.clear .clear].
    </p>

    <h3>[method:null renderBufferDirect]([param:Camera camera], [param:Fog fog], [param:Geometry geometry], [param:Material material], [param:Object3D object], [param:Object group])</h3>
    <p>Рендеринг группы геометрии буфера с использованием камеры и с указанным материалом.</p>

    <h3>[method:null renderBufferImmediate]([param:Object3D object], [param:WebGLProgram program])</h3>
    <p>object - экземпляр [page:Object3D]<br />
    program - экземпляр  [page:WebGLProgram]<br />

    Рендерит экземпляр [page:ImmediateRenderObject]. Вызывается функцией renderObjectImmediate().
    </p>

    <h3>[method:null resetState]()</h3>
    <p>Может использоваться для сброса внутреннего состояния WebGL. Этот метод наиболее актуален для приложений, которые используют один контекст WebGL в нескольких библиотеках WebGL.</p>

    <h3>[method:null setAnimationLoop]([param:Function callback])</h3>
    <p>[page:Function callback] — Функция будет вызываться каждый доступный кадр. Если передано `null`, это остановит любую уже идущую анимацию.</p>
    <p>Встроенная функция, которая может быть использована вместо [link:https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame requestAnimationFrame]. Для проектов WebXR необходимо использовать эту функцию.</p>

    <h3>[method:null setClearAlpha]([param:Float alpha])</h3>
    <p>Устанавливает прозрачную альфу. В качестве входного значения может быть использовано число в диапазоне от *0.0* до *1.0*.</p>

    <h3>[method:null setClearColor]([param:Color color], [param:Float alpha])</h3>
    <p>Устанавливает прозрачный цвет и непрозрачность.</p>

    <h3>[method:null setFramebuffer]([param:WebGLFramebuffer value])</h3>
    <p>Устанавливает заданный WebGLFramebuffer. Этот метод можно использовать, только если цель рендеринга не установлена через [page:WebGLRenderer.setRenderTarget .setRenderTarget]().</p>

    <h3>[method:null setPixelRatio]([param:number value])</h3>
    <p>Устанавливает соотношение пикселей устройства. Обычно используется для устройств с высоким разрешением, чтобы предотвратить смазывание холста при выводе.</p>

    <h3>[method:null setRenderTarget]([param:WebGLRenderTarget renderTarget], [param:Integer activeCubeFace], [param:Integer activeMipmapLevel])</h3>
    <p>
      renderTarget -- [page:WebGLRenderTarget renderTarget], который должен быть активирован. Если задано значение *null*, то вместо него в качестве активной цели рендеринга устанавливается холст.<br />
      activeCubeFace -- Указывает активную сторону куба (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) [page:WebGLCubeRenderTarget] (необязательно).<br />
      activeMipmapLevel -- Указывает активный уровень mipmap (необязательно).<br /><br />
      Этот метод устанавливает активный объект рендеринга.
    </p>

    <h3>[method:null setScissor]([param:Integer x], [param:Integer y], [param:Integer width], [param:Integer height])<br />
    [method:null setScissor]([param:Vector4 vector])</h3>

    <p>
      Параметры x, y, ширины и высоты области ножниц.<br />
      Опционально, 4-компонентный вектор, определяющий параметры региона.<br /><br />

      Устанавливает область ножниц от (x, y) до (x + ширина, y + высота).<br />
      (x, y) - левый нижний угол области ножниц.
    </p>

    <h3>[method:null setScissorTest]([param:Boolean boolean])</h3>
    <p>
      Включите или отключите проверку ножниц. Если этот параметр включен, только пиксели в пределах определенной области будут затронуты дальнейшими действиями рендеринга.
    </p>

    <h3>[method:null setOpaqueSort]([param:Function method])</h3>
    <p>
      Устанавливает пользовательскую функцию непрозрачной сортировки для WebGLRenderLists. Передайте null, чтобы использовать функцию по умолчанию painterSortStable.
    </p>

    <h3>[method:null setTransparentSort]([param:Function method])</h3>
    <p>
      Устанавливает пользовательскую прозрачную функцию сортировки для WebGLRenderLists. Передайте null, чтобы использовать функцию по умолчанию reversePainterSortStable.
    </p>

    <h3>[method:null setSize]([param:Integer width], [param:Integer height], [param:Boolean updateStyle])</h3>
    <p>
      Изменяет размер выводимого холста до (ширина, высота) с учетом соотношения пикселей устройства, а также устанавливает область просмотра в соответствии с этим размером, начиная с (0, 0).
      Установка [page:Boolean updateStyle] в false предотвращает любые изменения стиля выводимого холста.
    </p>

    <h3>[method:null setViewport]([param:Integer x], [param:Integer y], [param:Integer width], [param:Integer height])<br />
    [method:null setViewport]([param:Vector4 vector])</h3>

    <p>
      Параметры x, y, ширины и высоты области просмотра.<br />
      Опционально, 4-компонентный вектор, задающий параметры видового экрана.<br /><br />

      Устанавливает область просмотра для рендеринга из (x, y) в (x + ширина, y + высота).<br />
      (x, y) - левый нижний угол области.
    </p>

    [sourceHint]
  </body>
</html>
