<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <base href="../../../">
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css">
  </head>
  <body>
    [page:Material] &rarr;

    <h1>[name]</h1>

    <p class="desc">
      Материал, отрисованный с помощью пользовательских шейдеров. Шейдер - это небольшая программа, написанная на языке
      [ссылка:https://www.khronos.org/files/opengles_shading_language.pdf GLSL], которая выполняется на GPU.
      При необходимости вы можете использовать пользовательские шейдеры чтобы:
    <ul>
      <li>реализовать эффект, не включенный ни в один из встроенных [page:Material materials].</li>
      <li>объединять множество объектов в один [page:BufferGeometry] для повышения производительности.</li>
    </ul>
    При использовании *ShaderMaterial* следует помнить о следующих моментах:

    <ul>
      <li>
        Материал *ShaderMaterial* будет правильно отображаться только с помощью [page:WebGLRenderer],
        поскольку GLSL-код в свойствах [link:https://en.wikipedia.org/wiki/Shader#Vertex_shaders vertexShader]
        и [link:https://en.wikipedia.org/wiki/Shader#Pixel_shaders fragmentShader] свойствах должен
        быть скомпилирован и запущен на GPU с помощью WebGL.
      </li>
      <li>
        Начиная с v3d r72, прямое назначение атрибутов в ShaderMaterial больше не поддерживается.
        Вместо этого необходимо использовать экземпляр [page:BufferGeometry],
        используя экземпляры [page:BufferAttribute] для определения пользовательских атрибутов.
      </li>
      <li>
        Начиная с v3d r77, экземпляры [page:WebGLRenderTarget] или [page:WebGLCubeRenderTarget]
        больше не должны использоваться в качестве униформ. Вместо этого должно использоваться их свойство [page:Texture texture].
      </li>
      <li>
        Встроенные атрибуты и униформы передаются шейдерам вместе с вашим кодом.
        Если вы не хотите, чтобы [page:WebGLProgram] добавляла что-либо в ваш код шейдера, вы можете использовать
        [page:RawShaderMaterial] вместо этого класса.
      </li>
      <li>
        Вы можете использовать директивы #pragma unroll_loop_start и #pragma unroll_loop_end для того, чтобы развернуть цикл в GLSL препроцессором шейдера.
        Директива должна быть размещена прямо над циклом. Форматирование цикла должно соответствовать определенному стандарту.
        <ul>
          <li>
           Цикл должен быть [link:https://en.wikipedia.org/wiki/Normalized_loop нормализован].
          </li>
          <!-- Verge3D -->
          <li>
            Переменная цикла должна быть валидным идентификатором.
          </li>
          <li>
            Использование переменной цикла должно быть ограничено простой индексацией, например, myVariable[i] или заключено в скобки, например, int counter = (i);.
          </li>
          <li>
            Условие выхода должно быть "<" или "<=".
          </li>
          <li>
            Цикл должен использовать определенное форматирование символов пробела.
          </li>
          <li>
            Поддерживаются встроенные циклы, каждый со своей директивой #pragma. Но GLSL-комментарии с неравными фигурными скобками внутри циклов будут нарушать разворачивание регулярного выражения.
          </li>
        </ul>
        <code>
    #pragma unroll_loop_start
    for (int i = 0; i < 10; i++) {

      // ...

    }
    #pragma unroll_loop_end
        </code>
      </li>
    </ul>
    </p>

    <h2>Пример</h2>

    <code>
    const material = new v3d.ShaderMaterial({

      uniforms: {

        time: { value: 1.0 },
        resolution: { value: new v3d.Vector2() }

      },

      vertexShader: document.getElementById('vertexShader').textContent,

      fragmentShader: document.getElementById('fragmentShader').textContent

    });
    </code>

    <h2>Вертексные шейдеры и фрагментные шейдеры</h2>

    <div>
      <p>Для каждого материала можно задать два разных типа шейдеров:</p>
      <ul>
        <li>
          Вертексный шейдер запускается первым; он получает *атрибуты*, вычисляет / манипулирует
          положением каждой отдельной вершины и передает дополнительные данные (*изменяющиеся*) фрагментному шейдеру.
        </li>
        <li>
          Фрагментный (или пиксельный) шейдер работает вторым; он задает цвет каждого отдельного "фрагмента"
          (пикселя), выводимого на экран.
        </li>
      </ul>
      <p>В шейдерах существует три типа переменных: форма, атрибуты и вариации:</p>
      <ul>
        <li>
          *Uniforms* - это переменные, которые имеют одинаковое значение для всех вершин - освещение, туман,
          и карты теней являются примерами данных, которые могут храниться в форме.
          К ним может обращаться как вершинный шейдер, так и шейдер фрагмента.
        </li>
        <li>
          *Attributes* - это переменные, связанные с каждой вершиной - например, положение вершины,
          нормаль грани и цвет вершины - все это примеры данных, которые хранятся в атрибутах.
          Доступ к атрибутам возможен <em>только</em> в вертексном шейдере.
        </li>
        <li>
          *Varyings* - это переменные, которые передаются из вертексного шейдера во фрагментный шейдер.
          Для каждого фрагмента значение каждой вариации будет плавно интерполировано из значений соседних вершин.
        </li>
      </ul>
      <p>
        Обратите внимание, что <em>в пределах</em> самого шейдера формы и атрибуты действуют как константы;
        вы можете изменять их значения только путем передачи различных значений в буферы из вашего кода JavaScript.
      </p>
    </div>


  <h2>Встроенные атрибуты и униформы</h2>

  <div>
      <p>
        [page:WebGLRenderer] по умолчанию предоставляет шейдерам множество атрибутов и форм; определения этих переменных добавляются в ваш код *fragmentShader* и *vertexShader* программой [page:WebGLProgram] при компиляции шейдера; вам не нужно декларировать их самостоятельно.
        Подробности об этих переменных см. в [page:WebGLProgram].
      </p>
      <p>
        Некоторые из этих форм или атрибутов (например, относящиеся к освещению, туману и т.д.) требуют установки свойств на материале, чтобы [page:WebGLRenderer] скопировал соответствующие значения на GPU - обязательно установите эти флажки, если вы хотите использовать эти возможности в собственном шейдере.
      </p>
      <p>
        Если вы не хотите, чтобы [page:WebGLProgram] добавлял что-либо в ваш код шейдера, вы можете использовать
        [page:RawShaderMaterial] вместо этого класса.
      </p>
    </div>


    <h2>Пользовательские атрибуты и униформы</h2>

    <div>
      <p>
        Как пользовательские атрибуты, так и униформы должны быть задекларированы в коде шейдера GLSL (в *vertexShader* и/или *fragmentShader*). Пользовательские униформы должны быть определены в свойстве *uniforms* вашего *ShaderMaterial*, тогда как любые пользовательские атрибуты должны быть определены через экземпляры [page:BufferAttribute]. Обратите внимание, что *varying* нужно объявлять только в коде шейдера (не в материале).
      </p>
      <p>
        Чтобы задекларировать пользовательский атрибут, обратитесь к странице [page:BufferGeometry] для ознакомления,
        и странице [page:BufferAttribute] для детального рассмотрения API *BufferAttribute*.
      </p>
      <p>
        При создании атрибутов каждый массив, который вы создаете для хранения данных атрибута, должен быть кратен размеру вашего типа данных. Например, если ваш атрибут имеет тип [page:Vector3 v3d.Vector3], и у вас 3000 вершин в массиве [page:BufferGeometry], значение вашего типизированного массива должно быть создано с длиной 3000 * 3, или 9000 (по одному значению на компонент). Таблица размеров каждого типа данных приведена ниже (для справки):
      </p>

      <table>
        <caption><a id="attribute-sizes">Attribute sizes</a></caption>
        <thead>
          <tr>
            <th>GLSL type</th>
            <th>JavaScript type</th>
            <th>Size</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>float</td>
            <td>[page:Number]</td>
            <td>1</td>
          </tr>
          <tr>
            <td>vec2</td>
            <td>[page:Vector2 v3d.Vector2]</td>
            <td>2</td>
          </tr>
          <tr>
            <td>vec3</td>
            <td>[page:Vector3 v3d.Vector3]</td>
            <td>3</td>
          </tr>
          <tr>
            <td>vec3</td>
            <td>[page:Color v3d.Color]</td>
            <td>3</td>
          </tr>
          <tr>
            <td>vec4</td>
            <td>[page:Vector4 v3d.Vector4]</td>
            <td>4</td>
          </tr>
        </tbody>
      </table>

      <p>
        Обратите внимание, что буферы атрибутов <em>не</em> обновляются автоматически при изменении их значений. Чтобы обновить пользовательские атрибуты, установите флажок *needsUpdate* в true на [page:BufferAttribute] геометрии (см. подробнее [page:BufferGeometry]).
      </p>

      <p>
        Чтобы задекларировать пользовательскую [page:Uniform], используйте свойство *uniforms*:
      <code>
      uniforms: {
        time: { value: 1.0 },
        resolution: { value: new v3d.Vector2() }
      }
      </code>
      </p>

      <p>
        Рекомендуется обновлять пользовательские значения [page:Uniform] в зависимости от [page:Object3D object] и [page:Camera camera] в [page:Object3D.onBeforeRender], поскольку [page:Material] может быть общим для [page:Mesh meshes], [page:Matrix4 matrixWorld] из [page:Scene] и [page:Camera] обновляются в [page:WebGLRenderer.render], а некоторые эффекты рендерят [page:Scene scene] со своими частными [page:Camera cameras].
      </p>

    </div>

    <h2>Конструктор</h2>

    <h3>[name]([param:Object parameters])</h3>
    <p>
      [page:Object parameters] — (необ.) объект с одним или несколькими свойствами, определяющими внешний вид материала.
      Сюда можно передать любое свойство материала (включая любое свойство, унаследованное от [page:Material]).
    </p>

    <h2>Свойства</h2>
    <p>Общие свойства см. в базовом классе [page:Material].</p>

    <h3>[property:Boolean clipping]</h3>
    <p>
      Определяет, поддерживает ли этот материал клиппинг; true - позволяет рендереру передавать униформу clippingPlanes. По умолчанию false.
    </p>

    <!-- Verge3D -->

    <h3>[property:Object customPrepTokens]</h3>
    <p>
      Пользовательские маркеры препроцессинга - объект, аналогичный свойству [page:.defines], но вместо добавления директивы #define для каждой пары ключ/значение они вручную заменяются в коде GLSL перед компиляцией шейдера. Используется в директиве #pragma unroll_loop для определения инициализатора цикла и значений условия так же, как и в директиве #define, но поскольку разворачивание выполняется до компиляции, эти значения также должны быть известны заранее, поэтому это свойство является отдельным контейнером для таких значений:
    <code>
    customPrepTokens: {
        MAX_SIZE: 10
    }
    </code>
    делает следующий код:
    <code>
for (int i = 1; i <= MAX_SIZE; i++) {
        // ...
}
    </code>
    перед компиляцией:
    <code>
for (int i = 1; i <= 10; i++) {
        // ...
}
    </code>
    </p>

    <h3>[property:Object defaultAttributeValues]</h3>
    <p>
      Если отрисованная геометрия не включает эти атрибуты, но материал включает, эти значения по умолчанию будут переданы шейдерам. Это позволяет избежать ошибок при отсутствии данных буфера.

      <code>
this.defaultAttributeValues = {
  'color': [1, 1, 1],
  'uv': [0, 0],
  'uv2': [0, 0]
};
      </code>

    </p>


    <h3>[property:Object defines]</h3>
    <p>
      Определяет пользовательские константы с помощью директив *#define* в коде GLSL для вертескного шейдера и фрагментного шейдера; каждая пара ключ/значение дает другую директиву:
    <code>
    defines: {
      FOO: 15,
      BAR: true
    }
    </code>
    дает линии
    <code>
    #define FOO 15
    #define BAR true
    </code>
    в коде GLSL.
    </p>

    <h3>[property:Object extensions]</h3>
    <p>
      Объект со следующими свойствами:
    <code>
this.extensions = {
  derivatives: false, // set to use derivatives
  fragDepth: false, // set to use fragment depth values
  drawBuffers: false, // set to use draw buffers
  shaderTextureLOD: false // set to use shader texture LOD
};
    </code>
    </p>


    <h3>[property:Boolean fog]</h3>
    <p>
      Определяет, влияет ли на цвет материала глобальные настройки тумана; true, чтобы передать шейдеру форму тумана. По умолчанию - false.
    </p>


    <h3>[property:String fragmentShader]</h3>
    <p>
      Код GLSL шейдера фрагментов.  Это фактический код шейдера. В приведенном примере код *vertexShader* и *fragmentShader* извлекается из DOM; его можно передать в виде строки напрямую или загрузить через AJAX.
    </p>

    <h3>[property:String glslVersion]</h3>
    <p>
      Определяет GLSL-версию пользовательского шейдерного кода. Актуально только для WebGL 2, чтобы определить, следует ли указывать
      GLSL 3.0 или нет. Допустимые значения: *v3d.GLSL1* или *v3d.GLSL3*. По умолчанию *null*.
    </p>

    <h3>[property:String index0AttributeName]</h3>
    <p>
      Если задано, то вызывается [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation gl.bindAttribLocation]
      чтобы связать общий индекс вершины с переменной атрибута.
      По умолчанию не определено.

    </p>

    <h3>[property:Boolean lights]</h3>
    <p>
      Определяет, использует ли этот материал освещение; true для передачи данных униформ, связанных с освещением, в этот шейдер. По умолчанию - false.
    </p>

    <h3>[property:Float linewidth]</h3>
    <p>Управляет толщиной вайрфрейма. По умолчанию 1.<br><br>

      Из-за ограничений [link:https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf OpenGL Core Profile]
    с [page:WebGLRenderer WebGL] рендерером на большинстве платформ ширина линии всегда будет равна 1, независимо от установленного значения.
    </p>


    <h3>[property:Boolean morphTargets]</h3>
    <p>
      Если установлено значение true, атрибуты morph target доступны в вертексном шейдере. По умолчанию *false*.
    </p>

    <h3>[property:Boolean morphNormals]</h3>
    <p>
      Если установлено значение true, атрибуты morph normal доступны в вертексном шейдере. По умолчанию *false*.
    </p>

    <h3>[property:Boolean flatShading]</h3>
    <p>
      Определяет, будет ли материал отображаться с плоским затенением. По умолчанию *false*.
    </p>

    <h3>[property:Boolean skinning]</h3>
    <p>
      Определяет, использует ли материал скиннинг; true для передачи атрибутов скиннинга в шейдер. По умолчанию *false*.
    </p>

    <h3>[property:Object uniforms]</h3>
    <p>
      Объект формы:
      <code>
{ "uniform1": { value: 1.0 }, "uniform2": { value: 2 } }
      </code>
      определяет униформы, которые будут переданы в код шейдера; ключи - имена униформ, значения - определения формы.
    <code>
    { value: 1.0 }
    </code>
    где *value* - значение униформы. Имена должны совпадать с именем формы,
    как определено в коде GLSL. Обратите внимание, что униформы обновляются на каждом кадре,
    поэтому обновление значения униформы немедленно обновит значение, доступное коду GLSL.
    </p>

    <h3>[property:Boolean uniformsNeedUpdate]</h3>
    <p>
      Может использоваться для принудительного изменения униформы при смене униформы в [page:Object3D.onBeforeRender](). По умолчанию *false*.
    </p>

    <h3>[property:Boolean vertexColors]</h3>
    <p>
      Определяет, будет ли использоваться раскраска вертексов. По умолчанию *false*.
    </p>

    <h3>[property:String vertexShader]</h3>
    <p>
      Код вертексного шейдера GLSL.  Это фактический код шейдера. В приведенном выше примере,
      код *vertexShader* и *fragmentShader* извлекается из DOM; он может быть передан
      в виде строки напрямую или загружаться через AJAX.
    </p>

    <h3>[property:Boolean wireframe]</h3>
    <p>
      Рендер геометрии виде сетки (используя GL_LINES вместо GL_TRIANGLES). По умолчанию false (т.е. рендеринг в виде плоских полигонов)..
    </p>

    <h3>[property:Float wireframeLinewidth]</h3>
    <p>Управляет толщиной вайрфрейма. По умолчанию 1.<br><br>

      Из-за ограничений [link:https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf OpenGL Core Profile]
      с [page:WebGLRenderer WebGL] рендерером на большинстве платформ ширина линии всегда будет равна 1, независимо от установленного значения.
    </p>



    <h2>Методы</h2>
    <p>Общие методы см. в базовом классе [page:Material].</p>

    <h3>[method:ShaderMaterial clone]() [param:ShaderMaterial this]</h3>
    <p>
      Генерирует мелкую копию этого материала. Обратите внимание, что вертексный и фрагментный шейдеры копируются <em>референсом</em>, как и описания *атрибутов*; это означает, что клоны материала будут иметь одинаковые скомпилированные [page:WebGLProgram]. Однако *униформы* копируются <em>по значению</em>, что позволяет иметь разные наборы униформ для разных копий материала.
    </p>

    [sourceHint]
  </body>
</html>
